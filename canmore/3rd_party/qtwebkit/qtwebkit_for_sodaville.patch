diff --git a/JavaScriptCore/runtime/UString.cpp b/JavaScriptCore/runtime/UString.cpp
index 9da669d..4d7779d 100644
--- a/JavaScriptCore/runtime/UString.cpp
+++ b/JavaScriptCore/runtime/UString.cpp
@@ -587,6 +587,8 @@ unsigned UString::rfind(const UString& f, unsigned pos) const
         pos = sz - fsz;
     if (fsz == 0)
         return pos;
+    if (fsz == 1)
+        return rfind(f[0], pos);
     unsigned fsizeminusone = (fsz - 1) * sizeof(UChar);
     const UChar* fdata = f.data();
     for (const UChar* c = data() + pos; c >= data(); c--) {
diff --git a/JavaScriptCore/yarr/RegexJIT.h b/JavaScriptCore/yarr/RegexJIT.h
index fd765bc..8b97013 100644
--- a/JavaScriptCore/yarr/RegexJIT.h
+++ b/JavaScriptCore/yarr/RegexJIT.h
@@ -32,7 +32,7 @@
 #include "RegexPattern.h"
 #include <UString.h>
 
-#include <pcre.h>
+#include <pcre/pcre.h>
 struct JSRegExp; // temporary, remove when fallback is removed.
 
 #if CPU(X86) && !COMPILER(MSVC)
diff --git a/WebCore/WebCore.pri b/WebCore/WebCore.pri
index 97ae526..402c48f 100644
--- a/WebCore/WebCore.pri
+++ b/WebCore/WebCore.pri
@@ -86,7 +86,7 @@ greaterThan(QT_MINOR_VERSION, 5) {
 
 # Nescape plugins support (NPAPI)
 !contains(DEFINES, ENABLE_NETSCAPE_PLUGIN_API=.) {
-    unix|win32-*:!embedded:!wince*: {
+    unix|win32-*:embedded:!wince*: {
         DEFINES += ENABLE_NETSCAPE_PLUGIN_API=1
     } else {
         DEFINES += ENABLE_NETSCAPE_PLUGIN_API=0
diff --git a/WebCore/WebCore.pro b/WebCore/WebCore.pro
index 981dba2..71433ba 100644
--- a/WebCore/WebCore.pro
+++ b/WebCore/WebCore.pro
@@ -909,6 +909,7 @@ SOURCES += \
     plugins/PluginInfoStore.cpp \
     plugins/PluginPackage.cpp \
     plugins/PluginStream.cpp \
+    plugins/PluginTimer.cpp \
     plugins/PluginView.cpp \
     rendering/AutoTableLayout.cpp \
     rendering/break_lines.cpp \
@@ -2188,20 +2189,22 @@ contains(DEFINES, ENABLE_NETSCAPE_PLUGIN_API=1) {
                 INCLUDEPATH += platform/mac
                 # Note: XP_MACOSX is defined in npapi.h
             } else {
-                !embedded {
+                embedded {
+                    SOURCES += \
+                        plugins/qt/PluginPackageQt.cpp \
+                        plugins/embedded/PluginViewEmbedded.cpp
+                    DEFINES += XP_EMBEDDED
+                }  else {
                     CONFIG += x11
                     LIBS += -lXrender
-                }
-                maemo5 {
-                    DEFINES += MOZ_PLATFORM_MAEMO=5
-                }
-                SOURCES += \
-                    plugins/qt/PluginContainerQt.cpp \
-                    plugins/qt/PluginPackageQt.cpp \
-                    plugins/qt/PluginViewQt.cpp
-                HEADERS += \
-                    plugins/qt/PluginContainerQt.h
-                DEFINES += XP_UNIX
+                    SOURCES += \
+                        plugins/qt/PluginContainerQt.cpp \
+                        plugins/qt/PluginPackageQt.cpp \
+                        plugins/qt/PluginViewQt.cpp
+                    HEADERS += \
+                        plugins/qt/PluginContainerQt.h
+                    DEFINES += XP_UNIX
+               }
             }
         }
     
@@ -2396,18 +2399,47 @@ contains(DEFINES, ENABLE_VIDEO=1) {
 
             tobe|!tobe: QT += mediaservices
         } else {
-            HEADERS += \
-                platform/graphics/qt/MediaPlayerPrivatePhonon.h
-
-            SOURCES += \
-                platform/graphics/qt/MediaPlayerPrivatePhonon.cpp
-
-            # Add phonon manually to prevent it from coming first in
-            # the include paths, as Phonon's path.h conflicts with
-            # WebCore's Path.h on case-insensitive filesystems.
-            qtAddLibrary(phonon)
-            INCLUDEPATH -= $$QMAKE_INCDIR_QT/phonon
-            INCLUDEPATH += $$QMAKE_INCDIR_QT/phonon
+            embedded {
+                INCLUDEPATH += \
+                    $$PWD/platform/graphics/embedded
+                HEADERS += platform/graphics/embedded/MediaPlayerBoxee.h \
+                            platform/graphics/embedded/qjson/json_parser.hh \
+                            platform/graphics/embedded/qjson/json_scanner.h \
+                            platform/graphics/embedded/qjson/location.hh \
+                            platform/graphics/embedded/qjson/parser.h \
+                            platform/graphics/embedded/qjson/parser_p.h \
+                            platform/graphics/embedded/qjson/parserrunnable.h \
+                            platform/graphics/embedded/qjson/position.hh \
+                            platform/graphics/embedded/qjson/qjson_debug.h \
+                            platform/graphics/embedded/qjson/qjson_export.h \
+                            platform/graphics/embedded/qjson/qobjecthelper.h \
+                            platform/graphics/embedded/qjson/serializer.h \
+                            platform/graphics/embedded/qjson/serializerrunnable.h \
+                            platform/graphics/embedded/qjson/stack.hh
+
+                SOURCES += platform/graphics/embedded/MediaPlayerBoxee.cpp \
+                           platform/graphics/embedded/qjson/json_parser.cc \
+                           platform/graphics/embedded/qjson/json_scanner.cpp \
+                           platform/graphics/embedded/qjson/parser.cpp \
+                           platform/graphics/embedded/qjson/parserrunnable.cpp \
+                           platform/graphics/embedded/qjson/qobjecthelper.cpp \
+                           platform/graphics/embedded/qjson/serializer.cpp \
+                           platform/graphics/embedded/qjson/serializerrunnable.cpp
+            } else {
+                HEADERS += \
+                    platform/graphics/qt/MediaPlayerPrivatePhonon.h
+
+                SOURCES += \
+                    platform/graphics/qt/MediaPlayerPrivatePhonon.cpp
+
+                # Add phonon manually to prevent it from coming first in
+                # the include paths, as Phonon's path.h conflicts with
+                # WebCore's Path.h on case-insensitive filesystems.
+                qtAddLibrary(phonon)
+                INCLUDEPATH -= $$QMAKE_INCDIR_QT/phonon
+                INCLUDEPATH += $$QMAKE_INCDIR_QT/phonon
+            }
+
             mac {
                 INCLUDEPATH -= $$QMAKE_LIBDIR_QT/phonon.framework/Headers
                 INCLUDEPATH += $$QMAKE_LIBDIR_QT/phonon.framework/Headers
diff --git a/WebCore/platform/graphics/MediaPlayer.cpp b/WebCore/platform/graphics/MediaPlayer.cpp
index 035d1c5..5b83ae7 100644
--- a/WebCore/platform/graphics/MediaPlayer.cpp
+++ b/WebCore/platform/graphics/MediaPlayer.cpp
@@ -49,6 +49,8 @@
 #include "MediaPlayerPrivateQuickTimeWin.h"
 #elif PLATFORM(GTK)
 #include "MediaPlayerPrivateGStreamer.h"
+#elif defined(XP_EMBEDDED)
+#include "MediaPlayerBoxee.h"
 #elif PLATFORM(QT)
 // QtMultimedia support is disabled currently.
 #if 1 || (QT_VERSION < 0x040700)
diff --git a/WebCore/platform/graphics/embedded/MediaPlayerBoxee.cpp b/WebCore/platform/graphics/embedded/MediaPlayerBoxee.cpp
new file mode 100644
index 0000000..f4d0880
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/MediaPlayerBoxee.cpp
@@ -0,0 +1,476 @@
+/*
+    Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "config.h"
+#include "MediaPlayerBoxee.h"
+
+#include "CString.h"
+#include "FrameLoaderClientQt.h"
+#include "FrameView.h"
+#include "GraphicsContext.h"
+#include "HTMLMediaElement.h"
+#include "HTMLVideoElement.h"
+#include "TimeRanges.h"
+#include "Widget.h"
+#include "qwebframe.h"
+#include "qwebpage.h"
+#include "NotImplemented.h"
+
+#include <limits>
+#include <wtf/HashSet.h>
+#include <QPainter>
+
+using namespace WTF;
+
+namespace WebCore {
+
+QVariant MediaPlayerPrivate::RunCommand(QString command, QVariantMap parameters, bool expectedResult) const
+{
+    Document* document = m_element->document();
+    if (!document)
+        document = m_element->ownerDocument();
+
+    Frame* frame = document ? document->frame() : 0;
+    FrameLoaderClientQt* frameLoader =  frame ? static_cast<FrameLoaderClientQt*>(frame->loader()->client()) : 0;
+
+    QVariantMap request;
+    request.insert("command", QVariant(command));
+    request.insert("parameters", parameters);
+
+    QByteArray serialized = ((MediaPlayerPrivate*) this)->m_serializer.serialize(request);
+
+    // javascript call for: boxeePlayer.handleRequest()    
+    QString js;
+    if(expectedResult)
+      js = "boxee.exec2('boxee.handleBrowserCommandResponse(\\'";
+    else
+      js = "boxee.exec('boxee.handleBrowserCommand(\\'";
+
+    js += QString(serialized);
+    js += "\\');')";
+
+//    fprintf(stderr, "********************** MediaPlayerPrivate::RunCommand: %s\n", js.toLocal8Bit().constData());
+
+    QVariant result;
+    if (frameLoader)
+    {
+        result = frameLoader->webFrame()->evaluateJavaScript(js);
+//        fprintf(stderr, "********************** MediaPlayerPrivate::RunCommand Done: %s\n", result.toString().toLocal8Bit().constData());   
+    }
+
+    return result;
+}
+
+MediaPlayerPrivateInterface* MediaPlayerPrivate::create(MediaPlayer* player)
+{
+    return new MediaPlayerPrivate(player);
+}
+
+void MediaPlayerPrivate::registerMediaEngine(MediaEngineRegistrar registrar)
+{
+    registrar(create, getSupportedTypes, supportsType);
+}
+
+void MediaPlayerPrivate::getSupportedTypes(HashSet<String> &supported)
+{
+    supported.add("video/mpeg");
+    supported.add("video/quicktime");
+    supported.add("video/mp4");
+    supported.add("video/wmv");
+    supported.add("video/3gpp");
+    supported.add("video/3gpp2");
+    supported.add("video/x-ms-asf");
+    supported.add("video/x-msvideo");
+    supported.add("video/x-ms-wmv");
+    supported.add("video/ogg");
+    supported.add("video/webm");
+}
+
+MediaPlayer::SupportsType MediaPlayerPrivate::supportsType(const String& mime, const String& codec)
+{
+    if (!mime.startsWith("audio/") && !mime.startsWith("video/"))
+        return MediaPlayer::IsNotSupported;
+
+    return MediaPlayer::IsSupported;
+}
+
+MediaPlayerPrivate::MediaPlayerPrivate(MediaPlayer* player)
+    : m_player(player), 
+      m_isVisible(false), 
+      m_paused(true), 
+      m_networkState(MediaPlayer::Empty),
+      m_readyState(MediaPlayer::HaveNothing)
+{
+}
+
+MediaPlayerPrivate::~MediaPlayerPrivate()
+{
+}
+
+bool MediaPlayerPrivate::hasVideo() const
+{
+    return true;
+}
+
+bool MediaPlayerPrivate::hasAudio() const
+{
+    return true;
+}
+
+void MediaPlayerPrivate::setloaded()
+{
+    m_networkState = MediaPlayer::Idle;
+    m_player->networkStateChanged();
+    m_readyState = MediaPlayer::HaveEnoughData;
+    m_player->readyStateChanged();
+}
+
+void MediaPlayerPrivate::load(const String& url)
+{
+    // We are now loading
+    if (m_networkState != MediaPlayer::Loading) {
+        m_networkState = MediaPlayer::Loading;
+        m_player->networkStateChanged();
+    }
+
+    // And we don't have any data yet
+    if (m_readyState != MediaPlayer::HaveNothing) {
+        m_readyState = MediaPlayer::HaveNothing;
+        m_player->readyStateChanged();
+    }
+
+    m_duration = 0.0f;
+    m_paintedOnce = false;
+
+    m_element = static_cast<HTMLMediaElement*>(m_player->mediaPlayerClient());
+    QVariantMap parameters;
+    parameters.insert("url", QVariant(url));
+    RunCommand("MEDIAPLAYER.Load", parameters);
+    
+    setVisible(true);
+
+    m_networkState = MediaPlayer::Loading;
+    m_player->networkStateChanged();
+    m_readyState = MediaPlayer::HaveNothing;
+    m_player->readyStateChanged();
+
+#if 0
+    // We are now loading
+    if (m_networkState != MediaPlayer::Loading) {
+        m_networkState = MediaPlayer::Loading;
+        m_player->networkStateChanged();
+    }
+
+    // And we don't have any data yet
+    if (m_readyState != MediaPlayer::HaveNothing) {
+        m_readyState = MediaPlayer::HaveNothing;
+        m_player->readyStateChanged();
+    }
+
+    const QUrl rUrl = QUrl(QString(url));
+    const QString scheme = rUrl.scheme().toLower();
+
+    // Grab the client media element
+    HTMLMediaElement* element = static_cast<HTMLMediaElement*>(m_player->mediaPlayerClient());
+
+    // Construct the media content with a network request if the resource is http[s]
+    if (scheme == "http" || scheme == "https") {
+        QNetworkRequest request = QNetworkRequest(rUrl);
+
+        // Grab the current document
+        Document* document = element->document();
+        if (!document)
+            document = element->ownerDocument();
+
+        // Grab the frame and network manager
+        Frame* frame = document ? document->frame() : 0;
+        FrameLoaderClientQt* frameLoader =  frame ? static_cast<FrameLoaderClientQt*>(frame->loader()->client()) : 0;
+        QNetworkAccessManager* manager = frameLoader ? frameLoader->webFrame()->page()->networkAccessManager() : 0;
+
+        if (document && manager) {
+            // Set the cookies
+            QNetworkCookieJar* jar = manager->cookieJar();
+            QList<QNetworkCookie> cookies = jar->cookiesForUrl(rUrl);
+
+            // Don't set the header if there are no cookies.
+            // This prevents a warning from being emitted.
+            if (!cookies.isEmpty())
+                request.setHeader(QNetworkRequest::CookieHeader, qVariantFromValue(cookies));
+cookies
+            // Set the refferer, but not when requesting insecure content from a secure page
+            QUrl documentUrl = QUrl(QString(document->documentURI()));
+            if (documentUrl.scheme().toLower() == "http" || scheme == "https")
+                request.setRawHeader("Referer", documentUrl.toEncoded());
+
+            // Set the user agent
+            request.setRawHeader("User-Agent", frameLoader->userAgent(rUrl).utf8().data());
+        }
+
+        m_mediaPlayer->setMedia(QMediaContent(request));
+    } else {
+        // Otherwise, just use the URL
+        m_mediaPlayer->setMedia(QMediaContent(rUrl));
+    }
+
+    // Set the current volume and mute status
+    // We get these from the element, rather than the player, in case we have
+    // transitioned from a media engine which doesn't support muting, to a media
+    // engine which does.
+    m_mediaPlayer->setMuted(element->muted());
+    m_mediaPlayer->setVolume(static_cast<int>(element->volume() * 100.0));
+#endif
+}
+
+void MediaPlayerPrivate::cancelLoad()
+{
+    notImplemented();
+}
+
+void MediaPlayerPrivate::play()
+{
+    QVariantMap parameters;
+    RunCommand("MEDIAPLAYER.Play", parameters);
+    m_paused = false;
+}
+
+void MediaPlayerPrivate::pause()
+{
+    QVariantMap parameters;
+    RunCommand("MEDIAPLAYER.Pause", parameters);
+    m_paused = true;
+}
+
+bool MediaPlayerPrivate::paused() const
+{
+    return m_paused;
+}
+
+void MediaPlayerPrivate::seek(float position)
+{
+  //  if (!m_mediaPlayer->isSeekable())
+  //      return;
+
+  fprintf(stderr, "** NOT SEEKING\n");
+#if 0
+    QVariantMap parameters;
+    parameters.insert("position", QVariant(position));
+    QVariant result = RunCommand("MEDIAPLAYER.Seek", parameters);
+#endif
+
+
+#if 0
+
+
+    if (m_mediaPlayerControl && !m_mediaPlayerControl->availablePlaybackRanges().contains(position * 1000))
+        return;
+
+    if (m_isSeeking)
+        return;
+
+    if (position > duration())
+        position = duration();
+
+    // Seeking is most reliable when we're paused.
+    // Webkit will try to pause before seeking, but due to the asynchronous nature
+    // of the backend, the player may not actually be paused yet.
+    // In this case, we should queue the seek and wait until pausing has completed
+    // before attempting to seek.
+    if (m_mediaPlayer->state() == QMediaPlayer::PlayingState) {
+        m_mediaPlayer->pause();
+        m_isSeeking = true;
+        m_queuedSeek = static_cast<qint64>(position * 1000);
+
+        // Set a timeout, so that in the event that we don't get a state changed
+        // signal, we still attempt the seek.
+        QTimer::singleShot(1000, this, SLOT(queuedSeekTimeout()));
+    } else {
+        m_isSeeking = true;
+        m_mediaPlayer->setPosition(    QVariantMap parameters;
+    RunCommand("MEDIAPLAYER.CancelLoad", parameters);static_cast<qint64>(position * 1000));
+
+        // Set a timeout, in case we don't get a position changed signal
+        QTimer::singleShot(10000, this, SLOT(seekTimeout()));
+    }
+#endif
+}
+
+bool MediaPlayerPrivate::seeking() const
+{
+    return false;
+}
+
+float MediaPlayerPrivate::duration() const
+{
+//    if (m_readyState < MediaPlayer::HaveMetadata)
+//        return 0.0f;
+
+    if (m_duration != 0.0f)
+      return m_duration;
+
+    QVariantMap parameters;
+    QVariant result = RunCommand("MEDIAPLAYER.Duration", parameters, true);
+    float res = result.toFloat();
+    if (res != 0.0f)
+    {
+        MediaPlayerPrivate* tp = (MediaPlayerPrivate*)this;
+        tp->m_duration = res;
+        tp->setloaded();
+    }
+
+    return res;
+}
+
+float MediaPlayerPrivate::currentTime() const
+{
+    QVariantMap parameters;
+    QVariant result = RunCommand("MEDIAPLAYER.CurrentTime", parameters, true);
+    return result.toFloat();
+}
+
+PassRefPtr<TimeRanges> MediaPlayerPrivate::buffered() const
+{
+    notImplemented();
+    return TimeRanges::create();
+}
+
+float MediaPlayerPrivate::maxTimeSeekable() const
+{
+    notImplemented();
+    return 30.0f;
+}
+
+unsigned MediaPlayerPrivate::bytesLoaded() const
+{
+    const float dur = duration();
+
+    if (dur == 0.0)
+        return 0;
+
+    QVariantMap parameters;
+    QVariant result = RunCommand("MEDIAPLAYER.BytesLoaded", parameters, true);
+    int res = result.toInt();    
+
+    // boxee never gets to 100
+    if( res == 99 ) res = 100;
+    //printf("bytes loaded giving back %d\n", res);
+
+    return res;
+}
+
+unsigned MediaPlayerPrivate::totalBytes() const
+{
+    return 0;
+}
+
+void MediaPlayerPrivate::setRate(float rate)
+{
+    notImplemented();
+}
+
+void MediaPlayerPrivate::setVolume(float volume)
+{
+    QVariantMap parameters;
+    parameters.insert("volume", QVariant(QVariant(volume).toString()));
+    RunCommand("MEDIAPLAYER.SetVolume", parameters);
+}
+
+bool MediaPlayerPrivate::supportsMuting() const
+{
+    return true;
+}
+
+void MediaPlayerPrivate::setMuted(bool muted)
+{
+    QVariantMap parameters;
+    parameters.insert("muted", QVariant(muted));
+    RunCommand("MEDIAPLAYER.SetMuted", parameters);
+}
+
+MediaPlayer::NetworkState MediaPlayerPrivate::networkState() const
+{
+    return m_networkState;
+}
+
+MediaPlayer::ReadyState MediaPlayerPrivate::readyState() const
+{
+    return m_readyState;
+}
+
+void MediaPlayerPrivate::setVisible(bool visible)
+{
+    m_isVisible = visible;
+}
+
+void MediaPlayerPrivate::setSize(const IntSize& size)
+{
+    m_size = size;
+}
+
+IntSize MediaPlayerPrivate::naturalSize() const
+{
+    return m_size;
+}
+
+void MediaPlayerPrivate::paint(GraphicsContext* context, const IntRect& rect)
+{
+//    printf("**************** paint\n");
+
+    if (context->paintingDisabled())
+        return;
+
+    if (!m_isVisible)
+        return;
+
+    if (!m_paintedOnce)
+    {    
+        m_videoRect = rect;
+
+        QVariantMap parameters;
+        parameters.insert("x", QVariant(m_videoRect.x()));
+        parameters.insert("y", QVariant(m_videoRect.y()));
+        parameters.insert("width", QVariant(m_videoRect.width()));
+        parameters.insert("height", QVariant(m_videoRect.height()));
+        RunCommand("MEDIAPLAYER.Paint", parameters);
+    }
+
+    m_paintedOnce = true;
+
+    FloatRect fr(rect.x(), rect.y(), rect.width(), rect.height());
+    context->clearRect(fr);
+}
+
+#if USE(ACCELERATED_COMPOSITING)
+void MediaPlayerPrivate::acceleratedRenderingStateChanged()
+{
+    bool composited = m_player->mediaPlayerClient()->mediaPlayerRenderingCanBeAccelerated(m_player);
+    if (composited == m_composited)
+        return;
+
+    m_composited = composited;
+}
+
+PlatformLayer* MediaPlayerPrivate::platformLayer() const
+{
+    return 0;
+}
+#endif
+
+} // namespace WebCore
+
+#include "moc_MediaPlayerBoxee.cpp"
diff --git a/WebCore/platform/graphics/embedded/MediaPlayerBoxee.h b/WebCore/platform/graphics/embedded/MediaPlayerBoxee.h
new file mode 100644
index 0000000..7c36329
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/MediaPlayerBoxee.h
@@ -0,0 +1,113 @@
+/*
+    Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef MediaPlayerPrivateBoxee_h
+#define MediaPlayerPrivateBoxee_h
+
+#include "MediaPlayerPrivate.h"
+#include "qjson/serializer.h"
+#include "HTMLMediaElement.h"
+
+#include <QObject>
+#include <QVariant>
+
+namespace WebCore {
+
+class MediaPlayerPrivate : public QObject, public MediaPlayerPrivateInterface {
+
+    Q_OBJECT
+
+public:
+    static MediaPlayerPrivateInterface* create(MediaPlayer* player);
+    ~MediaPlayerPrivate();
+
+    static void registerMediaEngine(MediaEngineRegistrar);
+    static void getSupportedTypes(HashSet<String>&);
+    static MediaPlayer::SupportsType supportsType(const String&, const String&);
+    static bool isAvailable() { return true; }
+
+    bool hasVideo() const;
+    bool hasAudio() const;
+
+    void load(const String &url);
+    void cancelLoad();
+
+    void play();
+    void pause();
+
+    bool paused() const;
+    bool seeking() const;
+
+    float duration() const;
+    float currentTime() const;
+    void seek(float);
+
+    void setRate(float);
+    void setVolume(float);
+
+    bool supportsMuting() const;
+    void setMuted(bool);
+
+    MediaPlayer::NetworkState networkState() const;
+    MediaPlayer::ReadyState readyState() const;
+
+    PassRefPtr<TimeRanges> buffered() const;
+    float maxTimeSeekable() const;
+    unsigned bytesLoaded() const;
+    unsigned totalBytes() const;
+
+    void setVisible(bool);
+
+    IntSize naturalSize() const;
+    void setSize(const IntSize&);
+
+    void paint(GraphicsContext*, const IntRect&);
+
+    bool supportsFullscreen() const { return false; }
+
+#if USE(ACCELERATED_COMPOSITING)
+    // whether accelerated rendering is supported by the media engine for the current media.
+    virtual bool supportsAcceleratedRendering() const { return true; }
+    // called when the rendering system flips the into or out of accelerated rendering mode.
+    virtual void acceleratedRenderingStateChanged();
+    // returns an object that can be directly composited via GraphicsLayerQt (essentially a QGraphicsItem*)
+    virtual PlatformLayer* platformLayer() const;
+#endif
+
+private:
+    void setloaded();
+    MediaPlayerPrivate(MediaPlayer*);
+    QVariant RunCommand(QString command, QVariantMap parameters, bool expectedResult = false) const;
+
+    QJson::Serializer m_serializer;
+    MediaPlayer* m_player;
+    HTMLMediaElement* m_element;
+    bool m_composited;
+    bool m_isVisible;
+    IntRect m_videoRect;
+    bool m_paused;
+    IntSize m_size;
+    MediaPlayer::NetworkState m_networkState;
+    MediaPlayer::ReadyState m_readyState;
+    float m_duration;
+    bool m_paintedOnce;
+};
+}
+
+#endif // MediaPlayerPrivateQt_h
diff --git a/WebCore/platform/graphics/embedded/qjson/json_parser.cc b/WebCore/platform/graphics/embedded/qjson/json_parser.cc
new file mode 100644
index 0000000..a99be6c
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/json_parser.cc
@@ -0,0 +1,1096 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison LALR(1) parsers in C++
+
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+#include "json_parser.hh"
+
+/* User implementation prologue.  */
+
+
+/* Line 317 of lalr1.cc.  */
+#line 43 "json_parser.cc"
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* FIXME: INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#define YYUSE(e) ((void) (e))
+
+/* A pseudo ostream that takes yydebug_ into account.  */
+# define YYCDEBUG							\
+  for (bool yydebugcond_ = yydebug_; yydebugcond_; yydebugcond_ = false)	\
+    (*yycdebug_)
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)	\
+do {							\
+  if (yydebug_)						\
+    {							\
+      *yycdebug_ << Title << ' ';			\
+      yy_symbol_print_ ((Type), (Value), (Location));	\
+      *yycdebug_ << std::endl;				\
+    }							\
+} while (false)
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug_)				\
+    yy_reduce_print_ (Rule);		\
+} while (false)
+
+# define YY_STACK_PRINT()		\
+do {					\
+  if (yydebug_)				\
+    yystack_print_ ();			\
+} while (false)
+
+#else /* !YYDEBUG */
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_REDUCE_PRINT(Rule)
+# define YY_STACK_PRINT()
+
+#endif /* !YYDEBUG */
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+namespace yy
+{
+#if YYERROR_VERBOSE
+
+  /* Return YYSTR after stripping away unnecessary quotes and
+     backslashes, so that it's suitable for yyerror.  The heuristic is
+     that double-quoting is unnecessary unless the string contains an
+     apostrophe, a comma, or backslash (other than backslash-backslash).
+     YYSTR is taken from yytname.  */
+  std::string
+  json_parser::yytnamerr_ (const char *yystr)
+  {
+    if (*yystr == '"')
+      {
+        std::string yyr = "";
+        char const *yyp = yystr;
+
+        for (;;)
+          switch (*++yyp)
+            {
+            case '\'':
+            case ',':
+              goto do_not_strip_quotes;
+
+            case '\\':
+              if (*++yyp != '\\')
+                goto do_not_strip_quotes;
+              /* Fall through.  */
+            default:
+              yyr += *yyp;
+              break;
+
+            case '"':
+              return yyr;
+            }
+      do_not_strip_quotes: ;
+      }
+
+    return yystr;
+  }
+
+#endif
+
+  /// Build a parser object.
+  json_parser::json_parser (QJson::ParserPrivate* driver_yyarg)
+    : yydebug_ (false),
+      yycdebug_ (&std::cerr),
+      driver (driver_yyarg)
+  {
+  }
+
+  json_parser::~json_parser ()
+  {
+  }
+
+#if YYDEBUG
+  /*--------------------------------.
+  | Print this symbol on YYOUTPUT.  |
+  `--------------------------------*/
+
+  inline void
+  json_parser::yy_symbol_value_print_ (int yytype,
+			   const semantic_type* yyvaluep, const location_type* yylocationp)
+  {
+    YYUSE (yylocationp);
+    YYUSE (yyvaluep);
+    switch (yytype)
+      {
+         default:
+	  break;
+      }
+  }
+
+
+  void
+  json_parser::yy_symbol_print_ (int yytype,
+			   const semantic_type* yyvaluep, const location_type* yylocationp)
+  {
+    *yycdebug_ << (yytype < yyntokens_ ? "token" : "nterm")
+	       << ' ' << yytname_[yytype] << " ("
+	       << *yylocationp << ": ";
+    yy_symbol_value_print_ (yytype, yyvaluep, yylocationp);
+    *yycdebug_ << ')';
+  }
+#endif /* ! YYDEBUG */
+
+  void
+  json_parser::yydestruct_ (const char* yymsg,
+			   int yytype, semantic_type* yyvaluep, location_type* yylocationp)
+  {
+    YYUSE (yylocationp);
+    YYUSE (yymsg);
+    YYUSE (yyvaluep);
+
+    YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+    switch (yytype)
+      {
+  
+	default:
+	  break;
+      }
+  }
+
+  void
+  json_parser::yypop_ (unsigned int n)
+  {
+    yystate_stack_.pop (n);
+    yysemantic_stack_.pop (n);
+    yylocation_stack_.pop (n);
+  }
+
+  std::ostream&
+  json_parser::debug_stream () const
+  {
+    return *yycdebug_;
+  }
+
+  void
+  json_parser::set_debug_stream (std::ostream& o)
+  {
+    yycdebug_ = &o;
+  }
+
+
+  json_parser::debug_level_type
+  json_parser::debug_level () const
+  {
+    return yydebug_;
+  }
+
+  void
+  json_parser::set_debug_level (debug_level_type l)
+  {
+    yydebug_ = l;
+  }
+
+
+  int
+  json_parser::parse ()
+  {
+    /// Look-ahead and look-ahead in internal form.
+    int yychar = yyempty_;
+    int yytoken = 0;
+
+    /* State.  */
+    int yyn;
+    int yylen = 0;
+    int yystate = 0;
+
+    /* Error handling.  */
+    int yynerrs_ = 0;
+    int yyerrstatus_ = 0;
+
+    /// Semantic value of the look-ahead.
+    semantic_type yylval;
+    /// Location of the look-ahead.
+    location_type yylloc;
+    /// The locations where the error started and ended.
+    location yyerror_range[2];
+
+    /// $$.
+    semantic_type yyval;
+    /// @$.
+    location_type yyloc;
+
+    int yyresult;
+
+    YYCDEBUG << "Starting parse" << std::endl;
+
+
+    /* Initialize the stacks.  The initial state will be pushed in
+       yynewstate, since the latter expects the semantical and the
+       location values to have been already stored, initialize these
+       stacks with a primary value.  */
+    yystate_stack_ = state_stack_type (0);
+    yysemantic_stack_ = semantic_stack_type (0);
+    yylocation_stack_ = location_stack_type (0);
+    yysemantic_stack_.push (yylval);
+    yylocation_stack_.push (yylloc);
+
+    /* New state.  */
+  yynewstate:
+    yystate_stack_.push (yystate);
+    YYCDEBUG << "Entering state " << yystate << std::endl;
+    goto yybackup;
+
+    /* Backup.  */
+  yybackup:
+
+    /* Try to take a decision without look-ahead.  */
+    yyn = yypact_[yystate];
+    if (yyn == yypact_ninf_)
+      goto yydefault;
+
+    /* Read a look-ahead token.  */
+    if (yychar == yyempty_)
+      {
+	YYCDEBUG << "Reading a token: ";
+	yychar = yylex (&yylval, &yylloc, driver);
+      }
+
+
+    /* Convert token to internal form.  */
+    if (yychar <= yyeof_)
+      {
+	yychar = yytoken = yyeof_;
+	YYCDEBUG << "Now at end of input." << std::endl;
+      }
+    else
+      {
+	yytoken = yytranslate_ (yychar);
+	YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+      }
+
+    /* If the proper action on seeing token YYTOKEN is to reduce or to
+       detect an error, take that action.  */
+    yyn += yytoken;
+    if (yyn < 0 || yylast_ < yyn || yycheck_[yyn] != yytoken)
+      goto yydefault;
+
+    /* Reduce or error.  */
+    yyn = yytable_[yyn];
+    if (yyn <= 0)
+      {
+	if (yyn == 0 || yyn == yytable_ninf_)
+	goto yyerrlab;
+	yyn = -yyn;
+	goto yyreduce;
+      }
+
+    /* Accept?  */
+    if (yyn == yyfinal_)
+      goto yyacceptlab;
+
+    /* Shift the look-ahead token.  */
+    YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+    /* Discard the token being shifted unless it is eof.  */
+    if (yychar != yyeof_)
+      yychar = yyempty_;
+
+    yysemantic_stack_.push (yylval);
+    yylocation_stack_.push (yylloc);
+
+    /* Count tokens shifted since error; after three, turn off error
+       status.  */
+    if (yyerrstatus_)
+      --yyerrstatus_;
+
+    yystate = yyn;
+    goto yynewstate;
+
+  /*-----------------------------------------------------------.
+  | yydefault -- do the default action for the current state.  |
+  `-----------------------------------------------------------*/
+  yydefault:
+    yyn = yydefact_[yystate];
+    if (yyn == 0)
+      goto yyerrlab;
+    goto yyreduce;
+
+  /*-----------------------------.
+  | yyreduce -- Do a reduction.  |
+  `-----------------------------*/
+  yyreduce:
+    yylen = yyr2_[yyn];
+    /* If YYLEN is nonzero, implement the default value of the action:
+       `$$ = $1'.  Otherwise, use the top of the stack.
+
+       Otherwise, the following line sets YYVAL to garbage.
+       This behavior is undocumented and Bison
+       users should not rely upon it.  */
+    if (yylen)
+      yyval = yysemantic_stack_[yylen - 1];
+    else
+      yyval = yysemantic_stack_[0];
+
+    {
+      slice<location_type, location_stack_type> slice (yylocation_stack_, yylen);
+      YYLLOC_DEFAULT (yyloc, slice, yylen);
+    }
+    YY_REDUCE_PRINT (yyn);
+    switch (yyn)
+      {
+	  case 2:
+#line 80 "json_parser.yy"
+    {
+              driver->m_result = (yysemantic_stack_[(1) - (1)]);
+              qjsonDebug() << "json_parser - parsing finished";
+            ;}
+    break;
+
+  case 3:
+#line 85 "json_parser.yy"
+    {(yyval) = (yysemantic_stack_[(1) - (1)]); ;}
+    break;
+
+  case 4:
+#line 86 "json_parser.yy"
+    {(yyval) = (yysemantic_stack_[(1) - (1)]); ;}
+    break;
+
+  case 5:
+#line 88 "json_parser.yy"
+    {
+            qCritical()<< "json_parser - syntax error found, "
+                    << "forcing abort";
+            YYABORT;
+          ;}
+    break;
+
+  case 7:
+#line 95 "json_parser.yy"
+    { (yyval) = (yysemantic_stack_[(3) - (2)]); ;}
+    break;
+
+  case 8:
+#line 97 "json_parser.yy"
+    { (yyval) = QVariant (QVariantMap()); ;}
+    break;
+
+  case 9:
+#line 98 "json_parser.yy"
+    {
+            QVariantMap members = (yysemantic_stack_[(2) - (2)]).toMap();
+            (yysemantic_stack_[(2) - (2)]) = QVariant(); // Allow reuse of map
+            (yyval) = QVariant(members.unite ((yysemantic_stack_[(2) - (1)]).toMap()));
+          ;}
+    break;
+
+  case 10:
+#line 104 "json_parser.yy"
+    { (yyval) = QVariant (QVariantMap()); ;}
+    break;
+
+  case 11:
+#line 105 "json_parser.yy"
+    {
+          QVariantMap members = (yysemantic_stack_[(3) - (3)]).toMap();
+          (yysemantic_stack_[(3) - (3)]) = QVariant(); // Allow reuse of map
+          (yyval) = QVariant(members.unite ((yysemantic_stack_[(3) - (2)]).toMap()));
+          ;}
+    break;
+
+  case 12:
+#line 111 "json_parser.yy"
+    {
+            QVariantMap pair;
+            pair.insert ((yysemantic_stack_[(3) - (1)]).toString(), QVariant((yysemantic_stack_[(3) - (3)])));
+            (yyval) = QVariant (pair);
+          ;}
+    break;
+
+  case 13:
+#line 117 "json_parser.yy"
+    { (yyval) = (yysemantic_stack_[(3) - (2)]); ;}
+    break;
+
+  case 14:
+#line 119 "json_parser.yy"
+    { (yyval) = QVariant (QVariantList()); ;}
+    break;
+
+  case 15:
+#line 120 "json_parser.yy"
+    {
+          QVariantList members = (yysemantic_stack_[(2) - (2)]).toList();
+          (yysemantic_stack_[(2) - (2)]) = QVariant(); // Allow reuse of list
+          members.prepend ((yysemantic_stack_[(2) - (1)]));
+          (yyval) = QVariant(members);
+        ;}
+    break;
+
+  case 16:
+#line 127 "json_parser.yy"
+    { (yyval) = QVariant (QVariantList()); ;}
+    break;
+
+  case 17:
+#line 128 "json_parser.yy"
+    {
+            QVariantList members = (yysemantic_stack_[(3) - (3)]).toList();
+            (yysemantic_stack_[(3) - (3)]) = QVariant(); // Allow reuse of list
+            members.prepend ((yysemantic_stack_[(3) - (2)]));
+            (yyval) = QVariant(members);
+          ;}
+    break;
+
+  case 18:
+#line 135 "json_parser.yy"
+    { (yyval) = (yysemantic_stack_[(1) - (1)]); ;}
+    break;
+
+  case 19:
+#line 136 "json_parser.yy"
+    { (yyval) = (yysemantic_stack_[(1) - (1)]); ;}
+    break;
+
+  case 20:
+#line 137 "json_parser.yy"
+    { (yyval) = (yysemantic_stack_[(1) - (1)]); ;}
+    break;
+
+  case 21:
+#line 138 "json_parser.yy"
+    { (yyval) = (yysemantic_stack_[(1) - (1)]); ;}
+    break;
+
+  case 22:
+#line 139 "json_parser.yy"
+    { (yyval) = QVariant (true); ;}
+    break;
+
+  case 23:
+#line 140 "json_parser.yy"
+    { (yyval) = QVariant (false); ;}
+    break;
+
+  case 24:
+#line 141 "json_parser.yy"
+    {
+          QVariant null_variant;
+          (yyval) = null_variant;
+        ;}
+    break;
+
+  case 25:
+#line 146 "json_parser.yy"
+    {
+            if ((yysemantic_stack_[(1) - (1)]).toByteArray().startsWith('-')) {
+              (yyval) = QVariant (QVariant::LongLong);
+              (yyval).setValue((yysemantic_stack_[(1) - (1)]).toLongLong());
+            }
+            else {
+              (yyval) = QVariant (QVariant::ULongLong);
+              (yyval).setValue((yysemantic_stack_[(1) - (1)]).toULongLong());
+            }
+          ;}
+    break;
+
+  case 26:
+#line 156 "json_parser.yy"
+    {
+            const QByteArray value = (yysemantic_stack_[(2) - (1)]).toByteArray() + (yysemantic_stack_[(2) - (2)]).toByteArray();
+            (yyval) = QVariant(QVariant::Double);
+            (yyval).setValue(value.toDouble());
+          ;}
+    break;
+
+  case 27:
+#line 161 "json_parser.yy"
+    { (yyval) = QVariant ((yysemantic_stack_[(2) - (1)]).toByteArray() + (yysemantic_stack_[(2) - (2)]).toByteArray()); ;}
+    break;
+
+  case 28:
+#line 162 "json_parser.yy"
+    {
+            const QByteArray value = (yysemantic_stack_[(3) - (1)]).toByteArray() + (yysemantic_stack_[(3) - (2)]).toByteArray() + (yysemantic_stack_[(3) - (3)]).toByteArray();
+            (yyval) = QVariant (value);
+          ;}
+    break;
+
+  case 29:
+#line 167 "json_parser.yy"
+    { (yyval) = QVariant ((yysemantic_stack_[(2) - (1)]).toByteArray() + (yysemantic_stack_[(2) - (2)]).toByteArray()); ;}
+    break;
+
+  case 30:
+#line 168 "json_parser.yy"
+    { (yyval) = QVariant (QByteArray("-") + (yysemantic_stack_[(3) - (2)]).toByteArray() + (yysemantic_stack_[(3) - (3)]).toByteArray()); ;}
+    break;
+
+  case 31:
+#line 170 "json_parser.yy"
+    { (yyval) = QVariant (QByteArray("")); ;}
+    break;
+
+  case 32:
+#line 171 "json_parser.yy"
+    {
+          (yyval) = QVariant((yysemantic_stack_[(2) - (1)]).toByteArray() + (yysemantic_stack_[(2) - (2)]).toByteArray());
+        ;}
+    break;
+
+  case 33:
+#line 175 "json_parser.yy"
+    {
+          (yyval) = QVariant(QByteArray(".") + (yysemantic_stack_[(2) - (2)]).toByteArray());
+        ;}
+    break;
+
+  case 34:
+#line 179 "json_parser.yy"
+    { (yyval) = QVariant((yysemantic_stack_[(2) - (1)]).toByteArray() + (yysemantic_stack_[(2) - (2)]).toByteArray()); ;}
+    break;
+
+  case 35:
+#line 181 "json_parser.yy"
+    { (yyval) = (yysemantic_stack_[(3) - (2)]); ;}
+    break;
+
+  case 36:
+#line 183 "json_parser.yy"
+    { (yyval) = QVariant (QString(QLatin1String(""))); ;}
+    break;
+
+  case 37:
+#line 184 "json_parser.yy"
+    {
+                (yyval) = (yysemantic_stack_[(1) - (1)]);
+              ;}
+    break;
+
+
+    /* Line 675 of lalr1.cc.  */
+#line 618 "json_parser.cc"
+	default: break;
+      }
+    YY_SYMBOL_PRINT ("-> $$ =", yyr1_[yyn], &yyval, &yyloc);
+
+    yypop_ (yylen);
+    yylen = 0;
+    YY_STACK_PRINT ();
+
+    yysemantic_stack_.push (yyval);
+    yylocation_stack_.push (yyloc);
+
+    /* Shift the result of the reduction.  */
+    yyn = yyr1_[yyn];
+    yystate = yypgoto_[yyn - yyntokens_] + yystate_stack_[0];
+    if (0 <= yystate && yystate <= yylast_
+	&& yycheck_[yystate] == yystate_stack_[0])
+      yystate = yytable_[yystate];
+    else
+      yystate = yydefgoto_[yyn - yyntokens_];
+    goto yynewstate;
+
+  /*------------------------------------.
+  | yyerrlab -- here on detecting error |
+  `------------------------------------*/
+  yyerrlab:
+    /* If not already recovering from an error, report this error.  */
+    if (!yyerrstatus_)
+      {
+	++yynerrs_;
+	error (yylloc, yysyntax_error_ (yystate, yytoken));
+      }
+
+    yyerror_range[0] = yylloc;
+    if (yyerrstatus_ == 3)
+      {
+	/* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+	if (yychar <= yyeof_)
+	  {
+	  /* Return failure if at end of input.  */
+	  if (yychar == yyeof_)
+	    YYABORT;
+	  }
+	else
+	  {
+	    yydestruct_ ("Error: discarding", yytoken, &yylval, &yylloc);
+	    yychar = yyempty_;
+	  }
+      }
+
+    /* Else will try to reuse look-ahead token after shifting the error
+       token.  */
+    goto yyerrlab1;
+
+
+  /*---------------------------------------------------.
+  | yyerrorlab -- error raised explicitly by YYERROR.  |
+  `---------------------------------------------------*/
+  yyerrorlab:
+
+    /* Pacify compilers like GCC when the user code never invokes
+       YYERROR and the label yyerrorlab therefore never appears in user
+       code.  */
+    if (false)
+      goto yyerrorlab;
+
+    yyerror_range[0] = yylocation_stack_[yylen - 1];
+    /* Do not reclaim the symbols of the rule which action triggered
+       this YYERROR.  */
+    yypop_ (yylen);
+    yylen = 0;
+    yystate = yystate_stack_[0];
+    goto yyerrlab1;
+
+  /*-------------------------------------------------------------.
+  | yyerrlab1 -- common code for both syntax error and YYERROR.  |
+  `-------------------------------------------------------------*/
+  yyerrlab1:
+    yyerrstatus_ = 3;	/* Each real token shifted decrements this.  */
+
+    for (;;)
+      {
+	yyn = yypact_[yystate];
+	if (yyn != yypact_ninf_)
+	{
+	  yyn += yyterror_;
+	  if (0 <= yyn && yyn <= yylast_ && yycheck_[yyn] == yyterror_)
+	    {
+	      yyn = yytable_[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+	/* Pop the current state because it cannot handle the error token.  */
+	if (yystate_stack_.height () == 1)
+	YYABORT;
+
+	yyerror_range[0] = yylocation_stack_[0];
+	yydestruct_ ("Error: popping",
+		     yystos_[yystate],
+		     &yysemantic_stack_[0], &yylocation_stack_[0]);
+	yypop_ ();
+	yystate = yystate_stack_[0];
+	YY_STACK_PRINT ();
+      }
+
+    if (yyn == yyfinal_)
+      goto yyacceptlab;
+
+    yyerror_range[1] = yylloc;
+    // Using YYLLOC is tempting, but would change the location of
+    // the look-ahead.  YYLOC is available though.
+    YYLLOC_DEFAULT (yyloc, (yyerror_range - 1), 2);
+    yysemantic_stack_.push (yylval);
+    yylocation_stack_.push (yyloc);
+
+    /* Shift the error token.  */
+    YY_SYMBOL_PRINT ("Shifting", yystos_[yyn],
+		   &yysemantic_stack_[0], &yylocation_stack_[0]);
+
+    yystate = yyn;
+    goto yynewstate;
+
+    /* Accept.  */
+  yyacceptlab:
+    yyresult = 0;
+    goto yyreturn;
+
+    /* Abort.  */
+  yyabortlab:
+    yyresult = 1;
+    goto yyreturn;
+
+  yyreturn:
+    if (yychar != yyeof_ && yychar != yyempty_)
+      yydestruct_ ("Cleanup: discarding lookahead", yytoken, &yylval, &yylloc);
+
+    /* Do not reclaim the symbols of the rule which action triggered
+       this YYABORT or YYACCEPT.  */
+    yypop_ (yylen);
+    while (yystate_stack_.height () != 1)
+      {
+	yydestruct_ ("Cleanup: popping",
+		   yystos_[yystate_stack_[0]],
+		   &yysemantic_stack_[0],
+		   &yylocation_stack_[0]);
+	yypop_ ();
+      }
+
+    return yyresult;
+  }
+
+  // Generate an error message.
+  std::string
+  json_parser::yysyntax_error_ (int yystate, int tok)
+  {
+    std::string res;
+    YYUSE (yystate);
+#if YYERROR_VERBOSE
+    int yyn = yypact_[yystate];
+    if (yypact_ninf_ < yyn && yyn <= yylast_)
+      {
+	/* Start YYX at -YYN if negative to avoid negative indexes in
+	   YYCHECK.  */
+	int yyxbegin = yyn < 0 ? -yyn : 0;
+
+	/* Stay within bounds of both yycheck and yytname.  */
+	int yychecklim = yylast_ - yyn + 1;
+	int yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_;
+	int count = 0;
+	for (int x = yyxbegin; x < yyxend; ++x)
+	  if (yycheck_[x + yyn] == x && x != yyterror_)
+	    ++count;
+
+	// FIXME: This method of building the message is not compatible
+	// with internationalization.  It should work like yacc.c does it.
+	// That is, first build a string that looks like this:
+	// "syntax error, unexpected %s or %s or %s"
+	// Then, invoke YY_ on this string.
+	// Finally, use the string as a format to output
+	// yytname_[tok], etc.
+	// Until this gets fixed, this message appears in English only.
+	res = "syntax error, unexpected ";
+	res += yytnamerr_ (yytname_[tok]);
+	if (count < 5)
+	  {
+	    count = 0;
+	    for (int x = yyxbegin; x < yyxend; ++x)
+	      if (yycheck_[x + yyn] == x && x != yyterror_)
+		{
+		  res += (!count++) ? ", expecting " : " or ";
+		  res += yytnamerr_ (yytname_[x]);
+		}
+	  }
+      }
+    else
+#endif
+      res = YY_("syntax error");
+    return res;
+  }
+
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+  const signed char json_parser::yypact_ninf_ = -18;
+  const signed char
+  json_parser::yypact_[] =
+  {
+         5,   -18,   -18,     1,    -2,    19,   -18,   -18,   -18,     2,
+      20,    17,    21,    16,    18,   -18,   -18,   -18,   -18,   -18,
+      24,    23,   -18,    -8,   -18,   -18,   -18,    15,   -18,     1,
+     -18,    -2,    18,    18,   -18,   -18,    -2,   -18,    18,    18,
+      22,   -18,   -18,    17,   -18,   -18,   -18,    23,   -18,   -18,
+     -18,   -18,   -18
+  };
+
+  /* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
+     doesn't specify something else to do.  Zero means the default is an
+     error.  */
+  const unsigned char
+  json_parser::yydefact_[] =
+  {
+         0,     6,     5,     8,    14,     0,     2,     3,     4,    36,
+       0,    10,     0,     0,    31,    22,    23,    24,    20,    21,
+       0,    16,    19,    25,    18,     1,    37,     0,     7,     0,
+       9,     0,    31,    31,    29,    13,     0,    15,    31,    31,
+      26,    27,    35,    10,    12,    30,    32,    16,    33,    34,
+      28,    11,    17
+  };
+
+  /* YYPGOTO[NTERM-NUM].  */
+  const signed char
+  json_parser::yypgoto_[] =
+  {
+       -18,   -18,   -18,    33,   -18,    -7,     6,    37,   -18,    -9,
+     -13,   -18,   -18,   -17,   -18,    -1,    -3,   -18
+  };
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+  const signed char
+  json_parser::yydefgoto_[] =
+  {
+        -1,     5,     6,    18,    10,    30,    11,    19,    20,    37,
+      21,    22,    23,    34,    40,    41,    24,    27
+  };
+
+  /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule which
+     number is the opposite.  If zero, do what YYDEFACT says.  */
+  const signed char json_parser::yytable_ninf_ = -1;
+  const unsigned char
+  json_parser::yytable_[] =
+  {
+        12,     3,    38,     4,    39,     1,     2,    13,     3,    14,
+       4,    15,    16,    17,     9,    45,    46,     9,    44,    25,
+      26,    48,    49,    47,    28,    29,    12,    32,    31,    33,
+      35,    36,    42,     7,    39,    43,    51,     8,    52,    50
+  };
+
+  /* YYCHECK.  */
+  const unsigned char
+  json_parser::yycheck_[] =
+  {
+         3,     3,    10,     5,    12,     0,     1,     9,     3,    11,
+       5,    13,    14,    15,    16,    32,    33,    16,    31,     0,
+      18,    38,    39,    36,     4,     8,    29,    11,     7,    11,
+       6,     8,    17,     0,    12,    29,    43,     0,    47,    40
+  };
+
+  /* STOS_[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+  const unsigned char
+  json_parser::yystos_[] =
+  {
+         0,     0,     1,     3,     5,    20,    21,    22,    26,    16,
+      23,    25,    35,     9,    11,    13,    14,    15,    22,    26,
+      27,    29,    30,    31,    35,     0,    18,    36,     4,     8,
+      24,     7,    11,    11,    32,     6,     8,    28,    10,    12,
+      33,    34,    17,    25,    29,    32,    32,    29,    32,    32,
+      34,    24,    28
+  };
+
+#if YYDEBUG
+  /* TOKEN_NUMBER_[YYLEX-NUM] -- Internal symbol number corresponding
+     to YYLEX-NUM.  */
+  const unsigned short int
+  json_parser::yytoken_number_[] =
+  {
+         0,   256,   257,     1,     2,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16
+  };
+#endif
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+  const unsigned char
+  json_parser::yyr1_[] =
+  {
+         0,    19,    20,    21,    21,    21,    21,    22,    23,    23,
+      24,    24,    25,    26,    27,    27,    28,    28,    29,    29,
+      29,    29,    29,    29,    29,    30,    30,    30,    30,    31,
+      31,    32,    32,    33,    34,    35,    36,    36
+  };
+
+  /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+  const unsigned char
+  json_parser::yyr2_[] =
+  {
+         0,     2,     1,     1,     1,     1,     1,     3,     0,     2,
+       0,     3,     3,     3,     0,     2,     0,     3,     1,     1,
+       1,     1,     1,     1,     1,     1,     2,     2,     3,     2,
+       3,     0,     2,     2,     2,     3,     0,     1
+  };
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+  /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+     First, the terminals, then, starting at \a yyntokens_, nonterminals.  */
+  const char*
+  const json_parser::yytname_[] =
+  {
+    "\"end of file\"", "error", "$undefined", "\"{\"", "\"}\"", "\"[\"",
+  "\"]\"", "\":\"", "\",\"", "\"-\"", "\".\"", "\"digit\"",
+  "\"exponential\"", "\"true\"", "\"false\"", "\"null\"",
+  "\"open quotation mark\"", "\"close quotation mark\"", "\"string\"",
+  "$accept", "start", "data", "object", "members", "r_members", "pair",
+  "array", "values", "r_values", "value", "number", "int", "digits",
+  "fract", "exp", "string", "string_arg", 0
+  };
+#endif
+
+#if YYDEBUG
+  /* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+  const json_parser::rhs_number_type
+  json_parser::yyrhs_[] =
+  {
+        20,     0,    -1,    21,    -1,    22,    -1,    26,    -1,     1,
+      -1,     0,    -1,     3,    23,     4,    -1,    -1,    25,    24,
+      -1,    -1,     8,    25,    24,    -1,    35,     7,    29,    -1,
+       5,    27,     6,    -1,    -1,    29,    28,    -1,    -1,     8,
+      29,    28,    -1,    35,    -1,    30,    -1,    22,    -1,    26,
+      -1,    13,    -1,    14,    -1,    15,    -1,    31,    -1,    31,
+      33,    -1,    31,    34,    -1,    31,    33,    34,    -1,    11,
+      32,    -1,     9,    11,    32,    -1,    -1,    11,    32,    -1,
+      10,    32,    -1,    12,    32,    -1,    16,    36,    17,    -1,
+      -1,    18,    -1
+  };
+
+  /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+     YYRHS.  */
+  const unsigned char
+  json_parser::yyprhs_[] =
+  {
+         0,     0,     3,     5,     7,     9,    11,    13,    17,    18,
+      21,    22,    26,    30,    34,    35,    38,    39,    43,    45,
+      47,    49,    51,    53,    55,    57,    59,    62,    65,    69,
+      72,    76,    77,    80,    83,    86,    90,    91
+  };
+
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+  const unsigned char
+  json_parser::yyrline_[] =
+  {
+         0,    80,    80,    85,    86,    87,    93,    95,    97,    98,
+     104,   105,   111,   117,   119,   120,   127,   128,   135,   136,
+     137,   138,   139,   140,   141,   146,   156,   161,   162,   167,
+     168,   170,   171,   175,   179,   181,   183,   184
+  };
+
+  // Print the state stack on the debug stream.
+  void
+  json_parser::yystack_print_ ()
+  {
+    *yycdebug_ << "Stack now";
+    for (state_stack_type::const_iterator i = yystate_stack_.begin ();
+	 i != yystate_stack_.end (); ++i)
+      *yycdebug_ << ' ' << *i;
+    *yycdebug_ << std::endl;
+  }
+
+  // Report on the debug stream that the rule \a yyrule is going to be reduced.
+  void
+  json_parser::yy_reduce_print_ (int yyrule)
+  {
+    unsigned int yylno = yyrline_[yyrule];
+    int yynrhs = yyr2_[yyrule];
+    /* Print the symbols being reduced, and their result.  */
+    *yycdebug_ << "Reducing stack by rule " << yyrule - 1
+	       << " (line " << yylno << "), ";
+    /* The symbols being reduced.  */
+    for (int yyi = 0; yyi < yynrhs; yyi++)
+      YY_SYMBOL_PRINT ("   $" << yyi + 1 << " =",
+		       yyrhs_[yyprhs_[yyrule] + yyi],
+		       &(yysemantic_stack_[(yynrhs) - (yyi + 1)]),
+		       &(yylocation_stack_[(yynrhs) - (yyi + 1)]));
+  }
+#endif // YYDEBUG
+
+  /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+  json_parser::token_number_type
+  json_parser::yytranslate_ (int t)
+  {
+    static
+    const token_number_type
+    translate_table[] =
+    {
+           0,     3,     4,     5,     6,     7,     8,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2
+    };
+    if ((unsigned int) t <= yyuser_token_number_max_)
+      return translate_table[t];
+    else
+      return yyundef_token_;
+  }
+
+  const int json_parser::yyeof_ = 0;
+  const int json_parser::yylast_ = 39;
+  const int json_parser::yynnts_ = 18;
+  const int json_parser::yyempty_ = -2;
+  const int json_parser::yyfinal_ = 25;
+  const int json_parser::yyterror_ = 1;
+  const int json_parser::yyerrcode_ = 256;
+  const int json_parser::yyntokens_ = 19;
+
+  const unsigned int json_parser::yyuser_token_number_max_ = 257;
+  const json_parser::token_number_type json_parser::yyundef_token_ = 2;
+
+} // namespace yy
+
+#line 188 "json_parser.yy"
+
+
+int yy::yylex(YYSTYPE *yylval, yy::location *yylloc, QJson::ParserPrivate* driver)
+{
+  JSonScanner* scanner = driver->m_scanner;
+  yylval->clear();
+  int ret = scanner->yylex(yylval, yylloc);
+
+  qjsonDebug() << "json_parser::yylex - calling scanner yylval==|"
+           << yylval->toByteArray() << "|, ret==|" << QString::number(ret) << "|";
+  
+  return ret;
+}
+
+void yy::json_parser::error (const yy::location& yyloc,
+                                 const std::string& error)
+{
+  /*qjsonDebug() << yyloc.begin.line;
+  qjsonDebug() << yyloc.begin.column;
+  qjsonDebug() << yyloc.end.line;
+  qjsonDebug() << yyloc.end.column;*/
+  qjsonDebug() << "json_parser::error [line" << yyloc.end.line << "] -" << error.c_str() ;
+  driver->setError(QString::fromLatin1(error.c_str()), yyloc.end.line);
+}
+
diff --git a/WebCore/platform/graphics/embedded/qjson/json_parser.hh b/WebCore/platform/graphics/embedded/qjson/json_parser.hh
new file mode 100644
index 0000000..673923d
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/json_parser.hh
@@ -0,0 +1,321 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison LALR(1) parsers in C++
+
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C++ LALR(1) parser skeleton written by Akim Demaille.  */
+
+#ifndef PARSER_HEADER_H
+# define PARSER_HEADER_H
+
+#include <string>
+#include <iostream>
+#include "stack.hh"
+
+namespace yy
+{
+  class position;
+  class location;
+}
+
+/* First part of user declarations.  */
+#line 25 "json_parser.yy"
+
+  #include "parser_p.h"
+  #include "json_scanner.h"
+  #include "qjson_debug.h"
+
+  #include <QtCore/QByteArray>
+  #include <QtCore/QMap>
+  #include <QtCore/QString>
+  #include <QtCore/QVariant>
+
+  class JSonScanner;
+
+  namespace QJson {
+    class Parser;
+  }
+
+  #define YYERROR_VERBOSE 1
+
+
+/* Line 303 of lalr1.cc.  */
+#line 73 "json_parser.hh"
+
+#include "location.hh"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 1
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)		\
+do {							\
+  if (N)						\
+    {							\
+      (Current).begin = (Rhs)[1].begin;			\
+      (Current).end   = (Rhs)[N].end;			\
+    }							\
+  else							\
+    {							\
+      (Current).begin = (Current).end = (Rhs)[0].end;	\
+    }							\
+} while (false)
+#endif
+
+namespace yy
+{
+
+  /// A Bison parser.
+  class json_parser
+  {
+  public:
+    /// Symbol semantic values.
+#ifndef YYSTYPE
+    typedef int semantic_type;
+#else
+    typedef YYSTYPE semantic_type;
+#endif
+    /// Symbol locations.
+    typedef location location_type;
+    /// Tokens.
+    struct token
+    {
+      /* Tokens.  */
+   enum yytokentype {
+     END = 0,
+     CURLY_BRACKET_OPEN = 1,
+     CURLY_BRACKET_CLOSE = 2,
+     SQUARE_BRACKET_OPEN = 3,
+     SQUARE_BRACKET_CLOSE = 4,
+     COLON = 5,
+     COMMA = 6,
+     MINUS = 7,
+     DOT = 8,
+     DIGIT = 9,
+     E = 10,
+     TRUE_VAL = 11,
+     FALSE_VAL = 12,
+     NULL_VAL = 13,
+     QUOTMARKOPEN = 14,
+     QUOTMARKCLOSE = 15,
+     STRING = 16
+   };
+
+    };
+    /// Token type.
+    typedef token::yytokentype token_type;
+
+    /// Build a parser object.
+    json_parser (QJson::ParserPrivate* driver_yyarg);
+    virtual ~json_parser ();
+
+    /// Parse.
+    /// \returns  0 iff parsing succeeded.
+    virtual int parse ();
+
+    /// The current debugging stream.
+    std::ostream& debug_stream () const;
+    /// Set the current debugging stream.
+    void set_debug_stream (std::ostream &);
+
+    /// Type for debugging levels.
+    typedef int debug_level_type;
+    /// The current debugging level.
+    debug_level_type debug_level () const;
+    /// Set the current debugging level.
+    void set_debug_level (debug_level_type l);
+
+  private:
+    /// Report a syntax error.
+    /// \param loc    where the syntax error is found.
+    /// \param msg    a description of the syntax error.
+    virtual void error (const location_type& loc, const std::string& msg);
+
+    /// Generate an error message.
+    /// \param state   the state where the error occurred.
+    /// \param tok     the look-ahead token.
+    virtual std::string yysyntax_error_ (int yystate, int tok);
+
+#if YYDEBUG
+    /// \brief Report a symbol value on the debug stream.
+    /// \param yytype       The token type.
+    /// \param yyvaluep     Its semantic value.
+    /// \param yylocationp  Its location.
+    virtual void yy_symbol_value_print_ (int yytype,
+					 const semantic_type* yyvaluep,
+					 const location_type* yylocationp);
+    /// \brief Report a symbol on the debug stream.
+    /// \param yytype       The token type.
+    /// \param yyvaluep     Its semantic value.
+    /// \param yylocationp  Its location.
+    virtual void yy_symbol_print_ (int yytype,
+				   const semantic_type* yyvaluep,
+				   const location_type* yylocationp);
+#endif /* ! YYDEBUG */
+
+
+    /// State numbers.
+    typedef int state_type;
+    /// State stack type.
+    typedef stack<state_type>    state_stack_type;
+    /// Semantic value stack type.
+    typedef stack<semantic_type> semantic_stack_type;
+    /// location stack type.
+    typedef stack<location_type> location_stack_type;
+
+    /// The state stack.
+    state_stack_type yystate_stack_;
+    /// The semantic value stack.
+    semantic_stack_type yysemantic_stack_;
+    /// The location stack.
+    location_stack_type yylocation_stack_;
+
+    /// Internal symbol numbers.
+    typedef unsigned char token_number_type;
+    /* Tables.  */
+    /// For a state, the index in \a yytable_ of its portion.
+    static const signed char yypact_[];
+    static const signed char yypact_ninf_;
+
+    /// For a state, default rule to reduce.
+    /// Unless\a  yytable_ specifies something else to do.
+    /// Zero means the default is an error.
+    static const unsigned char yydefact_[];
+
+    static const signed char yypgoto_[];
+    static const signed char yydefgoto_[];
+
+    /// What to do in a state.
+    /// \a yytable_[yypact_[s]]: what to do in state \a s.
+    /// - if positive, shift that token.
+    /// - if negative, reduce the rule which number is the opposite.
+    /// - if zero, do what YYDEFACT says.
+    static const unsigned char yytable_[];
+    static const signed char yytable_ninf_;
+
+    static const unsigned char yycheck_[];
+
+    /// For a state, its accessing symbol.
+    static const unsigned char yystos_[];
+
+    /// For a rule, its LHS.
+    static const unsigned char yyr1_[];
+    /// For a rule, its RHS length.
+    static const unsigned char yyr2_[];
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+    /// For a symbol, its name in clear.
+    static const char* const yytname_[];
+#endif
+
+#if YYERROR_VERBOSE
+    /// Convert the symbol name \a n to a form suitable for a diagnostic.
+    virtual std::string yytnamerr_ (const char *n);
+#endif
+
+#if YYDEBUG
+    /// A type to store symbol numbers and -1.
+    typedef signed char rhs_number_type;
+    /// A `-1'-separated list of the rules' RHS.
+    static const rhs_number_type yyrhs_[];
+    /// For each rule, the index of the first RHS symbol in \a yyrhs_.
+    static const unsigned char yyprhs_[];
+    /// For each rule, its source line number.
+    static const unsigned char yyrline_[];
+    /// For each scanner token number, its symbol number.
+    static const unsigned short int yytoken_number_[];
+    /// Report on the debug stream that the rule \a r is going to be reduced.
+    virtual void yy_reduce_print_ (int r);
+    /// Print the state stack on the debug stream.
+    virtual void yystack_print_ ();
+#endif
+
+    /// Convert a scanner token number \a t to a symbol number.
+    token_number_type yytranslate_ (int t);
+
+    /// \brief Reclaim the memory associated to a symbol.
+    /// \param yymsg        Why this token is reclaimed.
+    /// \param yytype       The symbol type.
+    /// \param yyvaluep     Its semantic value.
+    /// \param yylocationp  Its location.
+    inline void yydestruct_ (const char* yymsg,
+			     int yytype,
+			     semantic_type* yyvaluep,
+			     location_type* yylocationp);
+
+    /// Pop \a n symbols the three stacks.
+    inline void yypop_ (unsigned int n = 1);
+
+    /* Constants.  */
+    static const int yyeof_;
+    /* LAST_ -- Last index in TABLE_.  */
+    static const int yylast_;
+    static const int yynnts_;
+    static const int yyempty_;
+    static const int yyfinal_;
+    static const int yyterror_;
+    static const int yyerrcode_;
+    static const int yyntokens_;
+    static const unsigned int yyuser_token_number_max_;
+    static const token_number_type yyundef_token_;
+
+    /* Debugging.  */
+    int yydebug_;
+    std::ostream* yycdebug_;
+
+
+    /* User arguments.  */
+    QJson::ParserPrivate* driver;
+  };
+}
+
+
+#endif /* ! defined PARSER_HEADER_H */
diff --git a/WebCore/platform/graphics/embedded/qjson/json_parser.yy b/WebCore/platform/graphics/embedded/qjson/json_parser.yy
new file mode 100644
index 0000000..ad8e105
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/json_parser.yy
@@ -0,0 +1,211 @@
+/* This file is part of QJSon
+  *
+  * Copyright (C) 2008 Flavio Castelli <flavio.castelli@gmail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public License
+  * along with this library; see the file COPYING.LIB.  If not, write to
+  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+  */
+
+%skeleton "lalr1.cc"
+%defines
+%define "parser_class_name" "json_parser"
+
+%{
+  #include "parser_p.h"
+  #include "json_scanner.h"
+  #include "qjson_debug.h"
+
+  #include <QtCore/QByteArray>
+  #include <QtCore/QMap>
+  #include <QtCore/QString>
+  #include <QtCore/QVariant>
+
+  class JSonScanner;
+
+  namespace QJson {
+    class Parser;
+  }
+
+  #define YYERROR_VERBOSE 1
+%}
+
+%parse-param { QJson::ParserPrivate* driver }
+%lex-param { QJson::ParserPrivate* driver }
+
+%locations
+
+%debug
+%error-verbose
+
+%token END 0 "end of file"
+
+%token CURLY_BRACKET_OPEN 1 "{"
+%token CURLY_BRACKET_CLOSE 2 "}"
+%token SQUARE_BRACKET_OPEN 3 "["
+%token SQUARE_BRACKET_CLOSE 4 "]"
+
+%token COLON 5 ":"
+%token COMMA 6 ","
+%token MINUS 7 "-"
+%token DOT 8 "."
+%token DIGIT 9 "digit"
+%token E 10 "exponential"
+%token TRUE_VAL 11 "true"
+%token FALSE_VAL 12 "false"
+%token NULL_VAL 13 "null"
+%token QUOTMARKOPEN 14 "open quotation mark"
+%token QUOTMARKCLOSE 15 "close quotation mark"
+
+%token STRING 16 "string"
+
+// define the initial token
+%start start
+
+%%
+
+// grammar rules
+
+start: data {
+              driver->m_result = $1;
+              qjsonDebug() << "json_parser - parsing finished";
+            };
+
+data: object {$$ = $1; }
+      | array {$$ = $1; }
+      | error
+          {
+            qCritical()<< "json_parser - syntax error found, "
+                    << "forcing abort";
+            YYABORT;
+          }
+      | END;
+
+object: CURLY_BRACKET_OPEN members CURLY_BRACKET_CLOSE { $$ = $2; };
+
+members: /* empty */ { $$ = QVariant (QVariantMap()); }
+        | pair r_members {
+            QVariantMap members = $2.toMap();
+            $2 = QVariant(); // Allow reuse of map
+            $$ = QVariant(members.unite ($1.toMap()));
+          };
+
+r_members: /* empty */ { $$ = QVariant (QVariantMap()); }
+        | COMMA pair r_members {
+          QVariantMap members = $3.toMap();
+          $3 = QVariant(); // Allow reuse of map
+          $$ = QVariant(members.unite ($2.toMap()));
+          };
+
+pair:   string COLON value {
+            QVariantMap pair;
+            pair.insert ($1.toString(), QVariant($3));
+            $$ = QVariant (pair);
+          };
+
+array: SQUARE_BRACKET_OPEN values SQUARE_BRACKET_CLOSE { $$ = $2; };
+
+values: /* empty */ { $$ = QVariant (QVariantList()); }
+        | value r_values {
+          QVariantList members = $2.toList();
+          $2 = QVariant(); // Allow reuse of list
+          members.prepend ($1);
+          $$ = QVariant(members);
+        };
+
+r_values: /* empty */ { $$ = QVariant (QVariantList()); }
+          | COMMA value r_values {
+            QVariantList members = $3.toList();
+            $3 = QVariant(); // Allow reuse of list
+            members.prepend ($2);
+            $$ = QVariant(members);
+          };
+
+value: string { $$ = $1; }
+        | number { $$ = $1; }
+        | object { $$ = $1; }
+        | array { $$ = $1; }
+        | TRUE_VAL { $$ = QVariant (true); }
+        | FALSE_VAL { $$ = QVariant (false); }
+        | NULL_VAL {
+          QVariant null_variant;
+          $$ = null_variant;
+        };
+
+number: int {
+            if ($1.toByteArray().startsWith('-')) {
+              $$ = QVariant (QVariant::LongLong);
+              $$.setValue($1.toLongLong());
+            }
+            else {
+              $$ = QVariant (QVariant::ULongLong);
+              $$.setValue($1.toULongLong());
+            }
+          }
+        | int fract {
+            const QByteArray value = $1.toByteArray() + $2.toByteArray();
+            $$ = QVariant(QVariant::Double);
+            $$.setValue(value.toDouble());
+          }
+        | int exp { $$ = QVariant ($1.toByteArray() + $2.toByteArray()); }
+        | int fract exp {
+            const QByteArray value = $1.toByteArray() + $2.toByteArray() + $3.toByteArray();
+            $$ = QVariant (value);
+          };
+
+int:  DIGIT digits { $$ = QVariant ($1.toByteArray() + $2.toByteArray()); }
+      | MINUS DIGIT digits { $$ = QVariant (QByteArray("-") + $2.toByteArray() + $3.toByteArray()); };
+
+digits: /* empty */ { $$ = QVariant (QByteArray("")); }
+        | DIGIT digits {
+          $$ = QVariant($1.toByteArray() + $2.toByteArray());
+        };
+
+fract: DOT digits {
+          $$ = QVariant(QByteArray(".") + $2.toByteArray());
+        };
+
+exp: E digits { $$ = QVariant($1.toByteArray() + $2.toByteArray()); };
+
+string: QUOTMARKOPEN string_arg QUOTMARKCLOSE { $$ = $2; };
+
+string_arg: /*empty */ { $$ = QVariant (QString(QLatin1String(""))); }
+            | STRING {
+                $$ = $1;
+              };
+
+%%
+
+int yy::yylex(YYSTYPE *yylval, yy::location *yylloc, QJson::ParserPrivate* driver)
+{
+  JSonScanner* scanner = driver->m_scanner;
+  yylval->clear();
+  int ret = scanner->yylex(yylval, yylloc);
+
+  qjsonDebug() << "json_parser::yylex - calling scanner yylval==|"
+           << yylval->toByteArray() << "|, ret==|" << QString::number(ret) << "|";
+  
+  return ret;
+}
+
+void yy::json_parser::error (const yy::location& yyloc,
+                                 const std::string& error)
+{
+  /*qjsonDebug() << yyloc.begin.line;
+  qjsonDebug() << yyloc.begin.column;
+  qjsonDebug() << yyloc.end.line;
+  qjsonDebug() << yyloc.end.column;*/
+  qjsonDebug() << "json_parser::error [line" << yyloc.end.line << "] -" << error.c_str() ;
+  driver->setError(QString::fromLatin1(error.c_str()), yyloc.end.line);
+}
diff --git a/WebCore/platform/graphics/embedded/qjson/json_scanner.cpp b/WebCore/platform/graphics/embedded/qjson/json_scanner.cpp
new file mode 100644
index 0000000..7f7b88f
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/json_scanner.cpp
@@ -0,0 +1,329 @@
+/* This file is part of QJson
+ *
+ * Copyright (C) 2008 Flavio Castelli <flavio.castelli@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "qjson_debug.h"
+#include "json_scanner.h"
+#include "json_parser.hh"
+
+#include <ctype.h>
+
+#include <QtCore/QDebug>
+#include <QtCore/QRegExp>
+
+#include <cassert>
+
+bool ishexnstring(const QString& string) {
+  for (int i = 0; i < string.length(); i++) {
+    if (isxdigit(string[i] == 0))
+      return false;
+  }
+  return true;
+}
+
+JSonScanner::JSonScanner(QIODevice* io)
+  : m_io (io)
+{
+  m_quotmarkClosed = true;
+  m_quotmarkCount = 0;
+}
+
+static QString unescape( const QByteArray& ba, bool* ok ) {
+  assert( ok );
+  *ok = false;
+  QString res;
+  QByteArray seg;
+  bool bs = false;
+  for ( int i = 0, size = ba.size(); i < size; ++i ) {
+    const char ch = ba[i];
+    if ( !bs ) {
+      if ( ch == '\\' )
+        bs = true;
+      else
+        seg += ch;
+    } else {
+      bs = false;
+      switch ( ch ) {
+        case 'b':
+          seg += '\b';
+          break;
+        case 'f':
+          seg += '\f';
+          break;
+        case 'n':
+          seg += '\n';
+          break;
+        case 'r':
+          seg += '\r';
+          break;
+        case 't':
+          seg += '\t';
+          break;
+        case 'u':
+        {
+          res += QString::fromUtf8( seg );
+          seg.clear();
+
+          if ( i > size - 5 ) {
+            //error
+            return QString();
+          }
+
+          const QString hex_digit1 = QString::fromUtf8( ba.mid( i + 1, 2 ) );
+          const QString hex_digit2 = QString::fromUtf8( ba.mid( i + 3, 2 ) );
+          i += 4;
+
+          if ( !ishexnstring( hex_digit1 ) || !ishexnstring( hex_digit2 ) ) {
+            qCritical() << "Not an hex string:" << hex_digit1 << hex_digit2;
+            return QString();
+          }
+          bool hexOk;
+          const ushort hex_code1 = hex_digit1.toShort( &hexOk, 16 );
+          if (!hexOk) {
+            qCritical() << "error converting hex value to short:" << hex_digit1;
+            return QString();
+          }
+          const ushort hex_code2 = hex_digit2.toShort( &hexOk, 16 );
+          if (!hexOk) {
+            qCritical() << "error converting hex value to short:" << hex_digit2;
+            return QString();
+          }
+
+          res += QChar(hex_code2, hex_code1);
+          break;
+        }
+        case '\\':
+          seg  += '\\';
+          break;
+        default:
+          seg += ch;
+          break;
+      }
+    }
+  }
+  res += QString::fromUtf8( seg );
+  *ok = true;
+  return res;
+}
+
+int JSonScanner::yylex(YYSTYPE* yylval, yy::location *yylloc)
+{
+  char ch;
+  
+  if (!m_io->isOpen()) {
+    qCritical() << "JSonScanner::yylex - io device is not open";
+    return -1;
+  }
+
+  yylloc->step();
+
+  do {
+    bool ret;
+    if (m_io->atEnd()) {
+      qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::END";
+      return yy::json_parser::token::END;
+    }
+    else
+      ret = m_io->getChar(&ch);
+
+    if (!ret) {
+      qCritical() << "JSonScanner::yylex - error reading from io device";
+      return -1;
+    }
+
+    qjsonDebug() << "JSonScanner::yylex - got |" << ch << "|";
+    
+    yylloc->columns();
+    
+    if (ch == '\n' || ch == '\r')
+      yylloc->lines();
+      
+  } while (m_quotmarkClosed && (isspace(ch) != 0));
+
+  if (m_quotmarkClosed && ((ch == 't') || (ch == 'T')
+      || (ch == 'n') || (ch == 'N'))) {
+    // check true & null value
+    const QByteArray buf = m_io->peek(3).toLower();
+
+    if (buf.length() == 3) {
+      if (buf == "rue") {
+        m_io->read (3);
+        yylloc->columns(3);
+        qjsonDebug() << "JSonScanner::yylex - TRUE_VAL";
+        return yy::json_parser::token::TRUE_VAL;
+      }
+      else if (buf == "ull") {
+        m_io->read (3);
+        yylloc->columns(3);
+        qjsonDebug() << "JSonScanner::yylex - NULL_VAL";
+        return yy::json_parser::token::NULL_VAL;
+      }
+    }
+  }
+  else if (m_quotmarkClosed && ((ch == 'f') || (ch == 'F'))) {
+    // check false value
+    const QByteArray buf = m_io->peek(4).toLower();
+    if (buf.length() == 4) {
+      if (buf == "alse") {
+        m_io->read (4);
+        yylloc->columns(4);
+        qjsonDebug() << "JSonScanner::yylex - FALSE_VAL";
+        return yy::json_parser::token::FALSE_VAL;
+      }
+    }
+  }
+  else if (m_quotmarkClosed && ((ch == 'e') || (ch == 'E'))) {
+    QByteArray ret(1, ch);
+    const QByteArray buf = m_io->peek(1);
+    if (!buf.isEmpty()) {
+      if ((buf[0] == '+' ) || (buf[0] == '-' )) {
+        ret += m_io->read (1);  
+        yylloc->columns();
+      }
+    }
+    *yylval = QVariant(QString::fromUtf8(ret));
+    return yy::json_parser::token::E;
+  }
+  
+  if (ch != '"' && !m_quotmarkClosed) {
+    // we're inside a " " block
+    QByteArray raw;
+    raw += ch;
+    char prevCh = ch;
+    bool escape_on = (ch == '\\') ? true : false;
+
+    while ( true ) {
+      char nextCh;
+      qint64 ret = m_io->peek(&nextCh, 1);
+      if (ret != 1) {
+        if (m_io->atEnd())
+          return yy::json_parser::token::END;
+        else
+          return -1;
+      } else if ( !escape_on && nextCh == '\"' ) {
+        bool ok;
+        const QString str = unescape( raw, &ok );
+        *yylval = ok ? str : QString();
+        return ok ? yy::json_parser::token::STRING : -1;
+      }
+#if 0
+      if ( prevCh == '\\' && nextCh != '"' && nextCh != '\\' && nextCh != '/' &&
+           nextCh != 'b' && nextCh != 'f' && nextCh != 'n' &&
+           nextCh != 'r' && nextCh != 't' && nextCh != 'u') {
+        qjsonDebug() << "Just read" << nextCh;
+        qjsonDebug() << "JSonScanner::yylex - error decoding escaped sequence";
+        return -1;
+       }
+#endif
+      m_io->read(1); // consume
+      raw += nextCh;
+      prevCh = nextCh;
+      if (escape_on)
+        escape_on = false;
+      else
+        escape_on = (prevCh == '\\') ? true : false;
+#if 0
+      if (nextCh == '\\') {
+        char buf;
+        if (m_io->getChar (&buf)) {
+          yylloc->columns();
+          if (((buf != '"') && (buf != '\\') && (buf != '/') &&
+              (buf != 'b') && (buf != 'f') && (buf != 'n') &&
+              (buf != 'r') && (buf != 't') && (buf != 'u'))) {
+                qjsonDebug() << "Just read" << buf;
+                qjsonDebug() << "JSonScanner::yylex - error decoding escaped sequence";
+                return -1;
+          }
+        } else {
+          qCritical() << "JSonScanner::yylex - error decoding escaped sequence : io error";
+          return -1;
+        }
+      }
+#endif
+    }
+  }
+  else if (isdigit(ch) != 0 && m_quotmarkClosed) {
+    *yylval = QVariant(QString::fromLatin1(QByteArray(&ch,1)));
+    qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::DIGIT";
+    return yy::json_parser::token::DIGIT;
+  }
+  else if (isalnum(ch) != 0) {
+    *yylval = QVariant(QString(QChar::fromLatin1(ch)));
+    qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::WORD ("
+             << ch << ")";
+    return yy::json_parser::token::STRING;
+  }
+  else if (ch == ':') {
+    // set yylval
+    qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::COLON";
+    return yy::json_parser::token::COLON;
+  }
+  else if (ch == '"') {
+    // yy::json_parser::token::QUOTMARK (")
+
+    // set yylval
+    m_quotmarkCount++;
+    if (m_quotmarkCount %2 == 0) {
+      m_quotmarkClosed = true;
+      m_quotmarkCount = 0;
+      qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::QUOTMARKCLOSE";
+      return yy::json_parser::token::QUOTMARKCLOSE;
+    }
+    else {
+      m_quotmarkClosed = false;
+      qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::QUOTMARKOPEN";
+      return yy::json_parser::token::QUOTMARKOPEN;
+    }
+  }
+  else if (ch == ',') {
+    qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::COMMA";
+    return yy::json_parser::token::COMMA;
+  }
+  else if (ch == '.') {
+    qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::DOT";
+    return yy::json_parser::token::DOT;
+  }
+  else if (ch == '-') {
+    qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::MINUS";
+    return yy::json_parser::token::MINUS;
+  }
+  else if (ch == '[') {
+    qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::SQUARE_BRACKET_OPEN";
+    return yy::json_parser::token::SQUARE_BRACKET_OPEN;
+  }
+  else if (ch == ']') {
+    qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::SQUARE_BRACKET_CLOSE";
+    return yy::json_parser::token::SQUARE_BRACKET_CLOSE;
+  }
+  else if (ch == '{') {
+    qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::CURLY_BRACKET_OPEN";
+    return yy::json_parser::token::CURLY_BRACKET_OPEN;
+  }
+  else if (ch == '}') {
+    qjsonDebug() << "JSonScanner::yylex - yy::json_parser::token::CURLY_BRACKET_CLOSE";
+    return yy::json_parser::token::CURLY_BRACKET_CLOSE;
+  }
+
+  //unknown char!
+  //TODO yyerror?
+  qCritical() << "JSonScanner::yylex - unknown char, returning -1";
+  return -1;
+}
+
+
diff --git a/WebCore/platform/graphics/embedded/qjson/json_scanner.h b/WebCore/platform/graphics/embedded/qjson/json_scanner.h
new file mode 100644
index 0000000..593426b
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/json_scanner.h
@@ -0,0 +1,52 @@
+/* This file is part of QJson
+ *
+ * Copyright (C) 2008 Flavio Castelli <flavio.castelli@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _JSON_SCANNER
+#define _JSON_SCANNER
+
+#include <fstream>
+#include <string>
+
+#include <QtCore/QIODevice>
+#include <QtCore/QVariant>
+
+#define YYSTYPE QVariant
+
+#include "parser_p.h"
+
+namespace yy {
+  class location;
+  int yylex(YYSTYPE *yylval, yy::location *yylloc, QJson::ParserPrivate* driver);
+}
+
+class JSonScanner
+{
+    public:
+        explicit JSonScanner(QIODevice* io);
+        int yylex(YYSTYPE* yylval, yy::location *yylloc);
+        
+    protected:
+        bool m_quotmarkClosed;
+        unsigned int m_quotmarkCount;
+        QIODevice* m_io;
+};
+
+#endif
+
diff --git a/WebCore/platform/graphics/embedded/qjson/location.hh b/WebCore/platform/graphics/embedded/qjson/location.hh
new file mode 100644
index 0000000..485fd77
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/location.hh
@@ -0,0 +1,145 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Locations for Bison parsers in C++
+
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/**
+ ** \file location.hh
+ ** Define the yy::location class.
+ */
+
+#ifndef BISON_LOCATION_HH
+# define BISON_LOCATION_HH
+
+# include <iostream>
+# include <string>
+# include "position.hh"
+
+namespace yy
+{
+
+  /// Abstract a location.
+  class location
+  {
+  public:
+
+    /// Construct a location.
+    location ()
+      : begin (), end ()
+    {
+    }
+
+
+    /// Initialization.
+    inline void initialize (std::string* fn)
+    {
+      begin.initialize (fn);
+      end = begin;
+    }
+
+    /** \name Line and Column related manipulators
+     ** \{ */
+  public:
+    /// Reset initial location to final location.
+    inline void step ()
+    {
+      begin = end;
+    }
+
+    /// Extend the current location to the COUNT next columns.
+    inline void columns (unsigned int count = 1)
+    {
+      end += count;
+    }
+
+    /// Extend the current location to the COUNT next lines.
+    inline void lines (unsigned int count = 1)
+    {
+      end.lines (count);
+    }
+    /** \} */
+
+
+  public:
+    /// Beginning of the located region.
+    position begin;
+    /// End of the located region.
+    position end;
+  };
+
+  /// Join two location objects to create a location.
+  inline const location operator+ (const location& begin, const location& end)
+  {
+    location res = begin;
+    res.end = end.end;
+    return res;
+  }
+
+  /// Add two location objects.
+  inline const location operator+ (const location& begin, unsigned int width)
+  {
+    location res = begin;
+    res.columns (width);
+    return res;
+  }
+
+  /// Add and assign a location.
+  inline location& operator+= (location& res, unsigned int width)
+  {
+    res.columns (width);
+    return res;
+  }
+
+  /** \brief Intercept output stream redirection.
+   ** \param ostr the destination output stream
+   ** \param loc a reference to the location to redirect
+   **
+   ** Avoid duplicate information.
+   */
+  inline std::ostream& operator<< (std::ostream& ostr, const location& loc)
+  {
+    position last = loc.end - 1;
+    ostr << loc.begin;
+    if (last.filename
+	&& (!loc.begin.filename
+	    || *loc.begin.filename != *last.filename))
+      ostr << '-' << last;
+    else if (loc.begin.line != last.line)
+      ostr << '-' << last.line  << '.' << last.column;
+    else if (loc.begin.column != last.column)
+      ostr << '-' << last.column;
+    return ostr;
+  }
+
+}
+
+#endif // not BISON_LOCATION_HH
diff --git a/WebCore/platform/graphics/embedded/qjson/parser.cpp b/WebCore/platform/graphics/embedded/qjson/parser.cpp
new file mode 100644
index 0000000..3096d17
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/parser.cpp
@@ -0,0 +1,114 @@
+/* This file is part of QJson
+ *
+ * Copyright (C) 2008 Flavio Castelli <flavio.castelli@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "parser.h"
+#include "parser_p.h"
+#include "json_parser.hh"
+#include "json_scanner.h"
+
+#include <QtCore/QBuffer>
+#include <QtCore/QStringList>
+#include <QtCore/QTextStream>
+#include <QtCore/QDebug>
+
+using namespace QJson;
+
+ParserPrivate::ParserPrivate() :
+    m_scanner(0)
+  , m_negate(false)
+  , m_error(false)
+{
+}
+
+ParserPrivate::~ParserPrivate()
+{
+  delete m_scanner;
+}
+
+void ParserPrivate::setError(QString errorMsg, int errorLine) {
+  m_error = true;
+  m_errorMsg = errorMsg;
+  m_errorLine = errorLine;
+}
+
+Parser::Parser() :
+    d(new ParserPrivate)
+{
+}
+
+Parser::~Parser()
+{
+  delete d;
+}
+
+QVariant Parser::parse (QIODevice* io, bool* ok)
+{
+  d->m_errorMsg.clear();
+  delete d->m_scanner;
+  d->m_scanner = 0;
+
+  if (!io->isOpen()) {
+    if (!io->open(QIODevice::ReadOnly)) {
+      if (ok != 0)
+        *ok = false;
+      qCritical ("Error opening device");
+      return QVariant();
+    }
+  }
+
+  if (!io->isReadable()) {
+    if (ok != 0)
+      *ok = false;
+    qCritical ("Device is not readable");
+    io->close();
+    return QVariant();
+  }
+
+  d->m_scanner = new JSonScanner (io);
+  yy::json_parser parser(d);
+  parser.parse();
+
+  delete d->m_scanner;
+  d->m_scanner = 0;
+
+  if (ok != 0)
+    *ok = !d->m_error;
+
+  io->close();
+  return d->m_result;
+}
+
+QVariant Parser::parse(const QByteArray& jsonString, bool* ok) {
+  QBuffer buffer;
+  buffer.open(QBuffer::ReadWrite);
+  buffer.write(jsonString);
+  buffer.seek(0);
+  return parse (&buffer, ok);
+}
+
+QString Parser::errorString() const
+{
+  return d->m_errorMsg;
+}
+
+int Parser::errorLine() const
+{
+  return d->m_errorLine;
+}
diff --git a/WebCore/platform/graphics/embedded/qjson/parser.h b/WebCore/platform/graphics/embedded/qjson/parser.h
new file mode 100644
index 0000000..8d323cd
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/parser.h
@@ -0,0 +1,80 @@
+/* This file is part of QJson
+ *
+ * Copyright (C) 2008 Flavio Castelli <flavio.castelli@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef QJSON_PARSER_H
+#define QJSON_PARSER_H
+
+#include "qjson_export.h"
+
+class QIODevice;
+class QVariant;
+
+namespace QJson {
+
+  class ParserPrivate;
+
+  /**
+  * @brief Main class used to convert JSON data to QVariant objects
+  */
+  class QJSON_EXPORT Parser
+  {
+    public:
+      Parser();
+      ~Parser();
+
+      /**
+      * Read JSON string from the I/O Device and converts it to a QVariant object
+      * @param io Input output device
+      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
+      * @returns a QVariant object generated from the JSON string
+      */
+      QVariant parse(QIODevice* io, bool* ok = 0);
+
+      /**
+      * This is a method provided for convenience.
+      * @param jsonData data containing the JSON object representation
+      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true.
+      * @returns a QVariant object generated from the JSON string
+      * @sa errorString
+      * @sa errorLine
+      */
+      QVariant parse(const QByteArray& jsonData, bool* ok = 0);
+
+      /**
+      * This method returns the error message
+      * @returns a QString object containing the error message of the last parse operation
+      * @sa errorLine
+      */
+      QString errorString() const;
+
+      /**
+      * This method returns line number where the error occurred
+      * @returns the line number where the error occurred
+      * @sa errorString
+      */
+      int errorLine() const;
+
+    private:
+      Q_DISABLE_COPY(Parser)
+      ParserPrivate* const d;
+  };
+}
+
+#endif // QJSON_PARSER_H
diff --git a/WebCore/platform/graphics/embedded/qjson/parser_p.h b/WebCore/platform/graphics/embedded/qjson/parser_p.h
new file mode 100644
index 0000000..e12b565
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/parser_p.h
@@ -0,0 +1,55 @@
+/* This file is part of QJson
+ *
+ * Copyright (C) 2008 Flavio Castelli <flavio.castelli@gmail.com>
+ * Copyright (C) 2009 Michael Leupold <lemma@confuego.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef QJSON_PARSER_P_H
+#define QJSON_PARSER_P_H
+
+#include "parser.h"
+
+#include <QtCore/QString>
+#include <QtCore/QVariant>
+
+class JSonScanner;
+
+namespace yy {
+  class json_parser;
+}
+
+namespace QJson {
+
+  class ParserPrivate
+  {
+    public:
+      ParserPrivate();
+      ~ParserPrivate();
+
+      void setError(QString errorMsg, int line);
+
+      JSonScanner* m_scanner;
+      bool m_negate;
+      bool m_error;
+      int m_errorLine;
+      QString m_errorMsg;
+      QVariant m_result;
+  };
+}
+
+#endif // QJSON_PARSER_H
diff --git a/WebCore/platform/graphics/embedded/qjson/parserrunnable.cpp b/WebCore/platform/graphics/embedded/qjson/parserrunnable.cpp
new file mode 100644
index 0000000..d09423e
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/parserrunnable.cpp
@@ -0,0 +1,68 @@
+/* This file is part of qjson
+  *
+  * Copyright (C) 2009 Flavio Castelli <flavio@castelli.name>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public License
+  * along with this library; see the file COPYING.LIB.  If not, write to
+  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+  */
+
+#include "parserrunnable.h"
+
+#include "parser.h"
+
+#include <QtCore/QDebug>
+#include <QtCore/QVariant>
+
+using namespace QJson;
+
+class QJson::ParserRunnable::Private
+{
+  public:
+    QByteArray m_data;
+};
+
+ParserRunnable::ParserRunnable(QObject* parent)
+    : QObject(parent),
+      QRunnable(),
+      d(new Private)
+{
+  qRegisterMetaType<QVariant>("QVariant");
+}
+
+ParserRunnable::~ParserRunnable()
+{
+  delete d;
+}
+
+void ParserRunnable::setData( const QByteArray& data ) {
+  d->m_data = data;
+}
+
+void ParserRunnable::run()
+{
+  qDebug() << Q_FUNC_INFO;
+
+  bool ok;
+  Parser parser;
+  QVariant result = parser.parse (d->m_data, &ok);
+  if (ok) {
+    qDebug() << "successfully converted json item to QVariant object";
+    emit parsingFinished(result, true, QString());
+  } else {
+    const QString errorText = tr("An error occured while parsing json: %1").arg(parser.errorString());
+    qCritical() << errorText;
+    emit parsingFinished(QVariant(), false, errorText);
+  }
+}
diff --git a/WebCore/platform/graphics/embedded/qjson/parserrunnable.h b/WebCore/platform/graphics/embedded/qjson/parserrunnable.h
new file mode 100644
index 0000000..822e1fd
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/parserrunnable.h
@@ -0,0 +1,67 @@
+/* This file is part of qjson
+  *
+  * Copyright (C) 2009 Flavio Castelli <flavio@castelli.name>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public License
+  * along with this library; see the file COPYING.LIB.  If not, write to
+  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+  */
+
+#ifndef PARSERRUNNABLE_H
+#define PARSERRUNNABLE_H
+
+#include "qjson_export.h"
+
+#include <QtCore/QObject>
+#include <QtCore/QRunnable>
+
+class QVariant;
+
+namespace QJson {
+  /**
+  * @brief Convenience class for converting JSON data to QVariant objects using a dedicated thread
+  */
+  class QJSON_EXPORT ParserRunnable  : public QObject, public QRunnable
+  {
+    Q_OBJECT
+    public:
+      /**
+      * This signal is emitted when the conversion process has been completed
+      * @param data contains the JSON data that has to be converted
+      * @param parent parent of the object
+      **/
+      explicit ParserRunnable(QObject* parent = 0);
+      ~ParserRunnable();
+
+      void setData( const QByteArray& data );
+
+      void run();
+
+    Q_SIGNALS:
+      /**
+      * This signal is emitted when the parsing process has been completed
+      * @param json contains the result of the parsing
+      * @param ok if a parsing error occurs ok is set to false, otherwise it's set to true.
+      * @param error_msg contains a string explaining the failure reason
+      **/
+      void parsingFinished(const QVariant& json, bool ok, const QString& error_msg);
+
+    private:
+      Q_DISABLE_COPY(ParserRunnable)
+      class Private;
+      Private* const d;
+  };
+}
+
+#endif // PARSERRUNNABLE_H
diff --git a/WebCore/platform/graphics/embedded/qjson/position.hh b/WebCore/platform/graphics/embedded/qjson/position.hh
new file mode 100644
index 0000000..27331d0
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/position.hh
@@ -0,0 +1,142 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Positions for Bison parsers in C++
+
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/**
+ ** \file position.hh
+ ** Define the yy::position class.
+ */
+
+#ifndef BISON_POSITION_HH
+# define BISON_POSITION_HH
+
+# include <iostream>
+# include <string>
+
+namespace yy
+{
+  /// Abstract a position.
+  class position
+  {
+  public:
+
+    /// Construct a position.
+    position ()
+      : filename (0), line (1), column (0)
+    {
+    }
+
+
+    /// Initialization.
+    inline void initialize (std::string* fn)
+    {
+      filename = fn;
+      line = 1;
+      column = 0;
+    }
+
+    /** \name Line and Column related manipulators
+     ** \{ */
+  public:
+    /// (line related) Advance to the COUNT next lines.
+    inline void lines (int count = 1)
+    {
+      column = 0;
+      line += count;
+    }
+
+    /// (column related) Advance to the COUNT next columns.
+    inline void columns (int count = 1)
+    {
+      int leftmost = 0;
+      int current  = column;
+      if (leftmost <= current + count)
+	column += count;
+      else
+	column = 0;
+    }
+    /** \} */
+
+  public:
+    /// File name to which this position refers.
+    std::string* filename;
+    /// Current line number.
+    unsigned int line;
+    /// Current column number.
+    unsigned int column;
+  };
+
+  /// Add and assign a position.
+  inline const position&
+  operator+= (position& res, const int width)
+  {
+    res.columns (width);
+    return res;
+  }
+
+  /// Add two position objects.
+  inline const position
+  operator+ (const position& begin, const int width)
+  {
+    position res = begin;
+    return res += width;
+  }
+
+  /// Add and assign a position.
+  inline const position&
+  operator-= (position& res, const int width)
+  {
+    return res += -width;
+  }
+
+  /// Add two position objects.
+  inline const position
+  operator- (const position& begin, const int width)
+  {
+    return begin + -width;
+  }
+
+  /** \brief Intercept output stream redirection.
+   ** \param ostr the destination output stream
+   ** \param pos a reference to the position to redirect
+   */
+  inline std::ostream&
+  operator<< (std::ostream& ostr, const position& pos)
+  {
+    if (pos.filename)
+      ostr << *pos.filename << ':';
+    return ostr << pos.line << '.' << pos.column;
+  }
+
+}
+#endif // not BISON_POSITION_HH
diff --git a/WebCore/platform/graphics/embedded/qjson/qjson_debug.h b/WebCore/platform/graphics/embedded/qjson/qjson_debug.h
new file mode 100644
index 0000000..5ae1da3
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/qjson_debug.h
@@ -0,0 +1,33 @@
+/* This file is part of qjson
+  *
+  * Copyright (C) 2009 Michael Leupold <lemma@confuego.org>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public License
+  * along with this library; see the file COPYING.LIB.  If not, write to
+  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+  */
+
+#ifndef QJSON_DEBUG_H
+#define QJSON_DEBUG_H
+
+#include <QtCore/QDebug>
+
+// define qjsonDebug()
+#ifdef QJSON_VERBOSE_DEBUG_OUTPUT
+  inline QDebug qjsonDebug() { return QDebug(QtDebugMsg); }
+#else
+  inline QNoDebug qjsonDebug() { return QNoDebug(); }
+#endif
+
+#endif
diff --git a/WebCore/platform/graphics/embedded/qjson/qjson_export.h b/WebCore/platform/graphics/embedded/qjson/qjson_export.h
new file mode 100644
index 0000000..c7f5325
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/qjson_export.h
@@ -0,0 +1,35 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2009 Pino Toscano <pino@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef QJSON_EXPORT_H
+#define QJSON_EXPORT_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QJSON_EXPORT
+# if defined(QJSON_MAKEDLL)
+   /* We are building this library */
+#  define QJSON_EXPORT Q_DECL_EXPORT
+# else
+   /* We are using this library */
+#  define QJSON_EXPORT Q_DECL_IMPORT
+# endif
+#endif
+
+#endif
diff --git a/WebCore/platform/graphics/embedded/qjson/qobjecthelper.cpp b/WebCore/platform/graphics/embedded/qjson/qobjecthelper.cpp
new file mode 100644
index 0000000..8bba181
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/qobjecthelper.cpp
@@ -0,0 +1,81 @@
+/* This file is part of qjson
+  *
+  * Copyright (C) 2009 Till Adam <adam@kde.org>
+  * Copyright (C) 2009 Flavio Castelli <flavio@castelli.name>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public License
+  * along with this library; see the file COPYING.LIB.  If not, write to
+  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+  */
+
+
+#include "qobjecthelper.h"
+
+#include <QtCore/QMetaObject>
+#include <QtCore/QMetaProperty>
+#include <QtCore/QObject>
+
+using namespace QJson;
+
+class QObjectHelper::QObjectHelperPrivate {
+};
+
+QObjectHelper::QObjectHelper()
+  : d (new QObjectHelperPrivate)
+{
+}
+
+QObjectHelper::~QObjectHelper()
+{
+  delete d;
+}
+
+QVariantMap QObjectHelper::qobject2qvariant( const QObject* object,
+                              const QStringList& ignoredProperties)
+{
+  QVariantMap result;
+  const QMetaObject *metaobject = object->metaObject();
+  int count = metaobject->propertyCount();
+  for (int i=0; i<count; ++i) {
+    QMetaProperty metaproperty = metaobject->property(i);
+    const char *name = metaproperty.name();
+
+    if (ignoredProperties.contains(QLatin1String(name)) || (!metaproperty.isReadable()))
+      continue;
+
+    QVariant value = object->property(name);
+    result[QLatin1String(name)] = value;
+ }
+  return result;
+}
+
+void QObjectHelper::qvariant2qobject(const QVariantMap& variant, QObject* object)
+{
+  QStringList properies;
+  const QMetaObject *metaobject = object->metaObject();
+  int count = metaobject->propertyCount();
+  for (int i=0; i<count; ++i) {
+    QMetaProperty metaproperty = metaobject->property(i);
+    if (metaproperty.isWritable()) {
+      properies << QLatin1String( metaproperty.name());
+    }
+  }
+
+  QVariantMap::const_iterator iter;
+  for (iter = variant.constBegin(); iter != variant.end(); iter++) {
+    if (properies.contains(iter.key())) {
+      object->setProperty(iter.key().toAscii(), iter.value());
+    }
+  }
+}
diff --git a/WebCore/platform/graphics/embedded/qjson/qobjecthelper.h b/WebCore/platform/graphics/embedded/qjson/qobjecthelper.h
new file mode 100644
index 0000000..7bf6b03
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/qobjecthelper.h
@@ -0,0 +1,143 @@
+/* This file is part of qjson
+  *
+  * Copyright (C) 2009 Flavio Castelli <flavio@castelli.name>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public License
+  * along with this library; see the file COPYING.LIB.  If not, write to
+  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+  */
+
+#ifndef QOBJECTHELPER_H
+#define QOBJECTHELPER_H
+
+#include "qjson_export.h"
+
+#include <QtCore/QLatin1String>
+#include <QtCore/QStringList>
+#include <QtCore/QVariantMap>
+
+class QObject;
+
+namespace QJson {
+  /**
+  * @brief Class used to convert QObject into QVariant and vivce-versa.
+  * During these operations only the class attributes defined as properties will
+  * be considered.
+  *
+  * Suppose the declaration of the Person class looks like this:
+  * \code
+  * class Person : public QObject
+    {
+      Q_OBJECT
+
+      Q_PROPERTY(QString name READ name WRITE setName)
+      Q_PROPERTY(int phoneNumber READ phoneNumber WRITE setPhoneNumber)
+      Q_PROPERTY(Gender gender READ gender WRITE setGender)
+      Q_PROPERTY(QDate dob READ dob WRITE setDob)
+      Q_ENUMS(Gender)
+
+     public:
+        Person(QObject* parent = 0);
+        ~Person();
+
+        QString name() const;
+        void setName(const QString& name);
+
+        int phoneNumber() const;
+        void setPhoneNumber(const int  phoneNumber);
+
+        enum Gender {Male, Female};
+        void setGender(Gender gender);
+        Gender gender() const;
+
+        QDate dob() const;
+        void setDob(const QDate& dob);
+
+      private:
+        QString m_name;
+        int m_phoneNumber;
+        Gender m_gender;
+        QDate m_dob;
+    };
+    \endcode
+
+    The following code will serialize an instance of Person to JSON :
+
+    \code
+    Person person;
+    person.setName("Flavio");
+    person.setPhoneNumber(123456);
+    person.setGender(Person::Male);
+    person.setDob(QDate(1982, 7, 12));
+
+    QVariantMap variant = QObjectHelper::qobject2qvariant(&person);
+    Serializer serializer;
+    qDebug() << serializer.serialize( variant);
+    \endcode
+
+    The generated output will be:
+    \code
+    { "dob" : "1982-07-12", "gender" : 0, "name" : "Flavio", "phoneNumber" : 123456 }
+    \endcode
+
+    It's also possible to initialize a QObject using the values stored inside of
+    a QVariantMap.
+
+    Suppose you have the following JSON data stored into a QString:
+    \code
+    { "dob" : "1982-07-12", "gender" : 0, "name" : "Flavio", "phoneNumber" : 123456 }
+    \endcode
+
+    The following code will initialize an already allocated instance of Person
+    using the JSON values:
+    \code
+    Parser parser;
+    QVariant variant = parser.parse(json);
+
+    Person person;
+    QObjectHelper::qvariant2qobject(variant.toMap(), &person);
+    \endcode
+
+    \sa Parser
+    \sa Serializer
+  */
+  class QJSON_EXPORT QObjectHelper {
+    public:
+      QObjectHelper();
+      ~QObjectHelper();
+      
+    /**
+    * This method converts a QObject instance into a QVariantMap.
+    *
+    * @param object The QObject instance to be converted.
+    * @param ignoredProperties Properties that won't be converted.
+    */
+    static QVariantMap qobject2qvariant( const QObject* object,
+                                  const QStringList& ignoredProperties = QStringList(QString(QLatin1String("objectName"))));
+
+    /**
+    * This method converts a QVariantMap instance into a QObject
+    *
+    * @param object The QObject instance to be converted.
+    */
+    static void qvariant2qobject(const QVariantMap& variant, QObject* object);
+
+    private:
+      Q_DISABLE_COPY(QObjectHelper)
+      class QObjectHelperPrivate;
+      QObjectHelperPrivate* const d;
+  };
+}
+
+#endif // QOBJECTHELPER_H
diff --git a/WebCore/platform/graphics/embedded/qjson/serializer.cpp b/WebCore/platform/graphics/embedded/qjson/serializer.cpp
new file mode 100644
index 0000000..f012246
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/serializer.cpp
@@ -0,0 +1,152 @@
+/* This file is part of qjson
+  *
+  * Copyright (C) 2009 Till Adam <adam@kde.org>
+  * Copyright (C) 2009 Flavio Castelli <flavio@castelli.name>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public License
+  * along with this library; see the file COPYING.LIB.  If not, write to
+  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+  */
+
+#include "serializer.h"
+
+#include <QtCore/QDataStream>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+
+using namespace QJson;
+
+class Serializer::SerializerPrivate {
+};
+
+Serializer::Serializer() : d( new SerializerPrivate ) {
+}
+
+Serializer::~Serializer() {
+  delete d;
+}
+
+void Serializer::serialize( const QVariant& v, QIODevice* io, bool* ok )
+{
+  Q_ASSERT( io );
+  if (!io->isOpen()) {
+    if (!io->open(QIODevice::WriteOnly)) {
+      if ( ok != 0 )
+        *ok = false;
+      qCritical ("Error opening device");
+      return;
+    }
+  }
+
+  if (!io->isWritable()) {
+    if (ok != 0)
+      *ok = false;
+    qCritical ("Device is not readable");
+    io->close();
+    return;
+  }
+
+  const QByteArray str = serialize( v );
+  if ( !str.isNull() ) {
+    QDataStream stream( io );
+    stream << str;
+  } else {
+    if ( ok )
+      *ok = false;
+  }
+}
+
+static QString sanitizeString( QString str )
+{
+  str.replace( QLatin1String( "\\" ), QLatin1String( "\\\\" ) );
+  str.replace( QLatin1String( "\"" ), QLatin1String( "\\\"" ) );
+  str.replace( QLatin1String( "\b" ), QLatin1String( "\\b" ) );
+  str.replace( QLatin1String( "\f" ), QLatin1String( "\\f" ) );
+  str.replace( QLatin1String( "\n" ), QLatin1String( "\\n" ) );
+  str.replace( QLatin1String( "\r" ), QLatin1String( "\\r" ) );
+  str.replace( QLatin1String( "\t" ), QLatin1String( "\\t" ) );
+  return QString( QLatin1String( "\"%1\"" ) ).arg( str );
+}
+
+static QByteArray join( const QList<QByteArray>& list, const QByteArray& sep ) {
+  QByteArray res;
+  Q_FOREACH( const QByteArray& i, list ) {
+    if ( !res.isEmpty() )
+      res += sep;
+    res += i;
+  }
+  return res;
+}
+
+QByteArray Serializer::serialize( const QVariant &v )
+{
+  QByteArray str;
+  bool error = false;
+
+  if ( ! v.isValid() ) { // invalid or null?
+    str = "null";
+  } else if ( v.type() == QVariant::List ) { // variant is a list?
+    const QVariantList list = v.toList();
+    QList<QByteArray> values;
+    Q_FOREACH( const QVariant& v, list )
+    {
+      QByteArray serializedValue = serialize( v );
+      if ( serializedValue.isNull() ) {
+        error = true;
+        break;
+      }
+      values << serializedValue;
+    }
+    str = "[ " + join( values, ", " ) + " ]";
+  } else if ( v.type() == QVariant::Map ) { // variant is a map?
+    const QVariantMap vmap = v.toMap();
+    QMapIterator<QString, QVariant> it( vmap );
+    str = "{ ";
+    QList<QByteArray> pairs;
+    while ( it.hasNext() ) {
+      it.next();
+      QByteArray serializedValue = serialize( it.value() );
+      if ( serializedValue.isNull() ) {
+        error = true;
+        break;
+      }
+      pairs << sanitizeString( it.key() ).toUtf8() + " : " + serializedValue;
+    }
+    str += join( pairs, ", " );
+    str += " }";
+  } else if (( v.type() == QVariant::String ) ||  ( v.type() == QVariant::ByteArray )) { // a string or a byte array?
+    str = sanitizeString( v.toString() ).toUtf8();
+  } else if ( v.type() == QVariant::Double ) { // a double?
+    str = QByteArray::number( v.toDouble() );
+    if( ! str.contains( "." ) && ! str.contains( "e" ) ) {
+      str += ".0";
+    }
+  } else if ( v.type() == QVariant::Bool ) { // boolean value?
+    str = ( v.toBool() ? "true" : "false" );
+  } else if ( v.type() == QVariant::ULongLong ) { // large unsigned number?
+    str = QByteArray::number( v.value<qulonglong>() );
+  } else if ( v.canConvert<qlonglong>() ) { // any signed number?
+    str = QByteArray::number( v.value<qlonglong>() );
+  } else if ( v.canConvert<QString>() ){ // can value be converted to string?
+    // this will catch QDate, QDateTime, QUrl, ...
+    str = sanitizeString( v.toString() ).toUtf8();
+    //TODO: catch other values like QImage, QRect, ...
+  } else {
+    error = true;
+  }
+  if ( !error )
+    return str;
+  else
+    return QByteArray();
+}
diff --git a/WebCore/platform/graphics/embedded/qjson/serializer.h b/WebCore/platform/graphics/embedded/qjson/serializer.h
new file mode 100644
index 0000000..fd301b2
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/serializer.h
@@ -0,0 +1,71 @@
+/* This file is part of qjson
+  *
+  * Copyright (C) 2009 Till Adam <adam@kde.org>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public License
+  * along with this library; see the file COPYING.LIB.  If not, write to
+  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+  */
+
+#ifndef QJSON_SERIALIZER_H
+#define QJSON_SERIALIZER_H
+
+#include "qjson_export.h"
+
+class QIODevice;
+class QString;
+class QVariant;
+
+namespace QJson {
+  /**
+  * @brief Main class used to convert QVariant objects to JSON data.
+  *
+  * QVariant objects are converted to a string containing the JSON data.
+  * If QVariant object is empty or not valid a <em>null</em> json object is returned.
+  */
+  class QJSON_EXPORT Serializer {
+  public:
+    Serializer();
+    ~Serializer();
+
+     /**
+      * This method generates a textual JSON representation and outputs it to the
+      * passed in I/O Device.
+      * @param variant The JSON document in its in-memory representation as generated by the
+      * parser.
+      * @param out Input output device
+      * @param ok if a conversion error occurs, *ok is set to false; otherwise *ok is set to true
+      */
+    void serialize( const QVariant& variant, QIODevice* out, bool* ok = 0 );
+
+    /**
+      * This is a method provided for convenience. It turns the passed in in-memory
+      * representation of the JSON document into a textual one, which is returned.
+      * If the returned string is empty, the document was empty. If it was null, there
+      * was a parsing error.
+      *
+      * @param variant The JSON document in its in-memory representation as generated by the
+      * parser.
+      */
+
+    QByteArray serialize( const QVariant& variant );
+
+  private:
+    Q_DISABLE_COPY(Serializer)
+    class SerializerPrivate;
+    SerializerPrivate* const d;
+  };
+}
+
+#endif // QJSON_SERIALIZER_H
diff --git a/WebCore/platform/graphics/embedded/qjson/serializerrunnable.cpp b/WebCore/platform/graphics/embedded/qjson/serializerrunnable.cpp
new file mode 100644
index 0000000..2e57c45
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/serializerrunnable.cpp
@@ -0,0 +1,60 @@
+#include "serializerrunnable.h"
+
+/* This file is part of qjson
+ *
+ * Copyright (C) 2009 Flavio Castelli <flavio@castelli.name>
+ *               2009 Frank Osterfeld <osterfeld@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "parserrunnable.h"
+#include "serializer.h"
+
+#include <QtCore/QDebug>
+#include <QtCore/QVariant>
+
+using namespace QJson;
+
+class SerializerRunnable::Private
+{
+public:
+  QVariant json;
+};
+
+SerializerRunnable::SerializerRunnable(QObject* parent)
+    : QObject(parent),
+      QRunnable(),
+      d(new Private)
+{
+  qRegisterMetaType<QVariant>("QVariant");
+}
+
+SerializerRunnable::~SerializerRunnable()
+{
+  delete d;
+}
+
+void SerializerRunnable::setJsonObject( const QVariant& json )
+{
+  d->json = json;
+}
+
+void SerializerRunnable::run()
+{
+  Serializer serializer;
+  emit parsingFinished( Serializer().serialize( d->json ), true, QString() );
+}
diff --git a/WebCore/platform/graphics/embedded/qjson/serializerrunnable.h b/WebCore/platform/graphics/embedded/qjson/serializerrunnable.h
new file mode 100644
index 0000000..c6b5fe1
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/serializerrunnable.h
@@ -0,0 +1,74 @@
+/* This file is part of qjson
+ *
+ * Copyright (C) 2009 Frank Osterfeld <osterfeld@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef SERIALIZERRUNNABLE_H
+#define SERIALIZERRUNNABLE_H
+
+#include "qjson_export.h"
+
+#include <QtCore/QObject>
+#include <QtCore/QRunnable>
+
+class QByteArray;
+class QString;
+class QVariant;
+
+namespace QJson {
+  /**
+  * @brief Convenience class for converting JSON data to QVariant objects using a dedicated thread
+  */
+  class QJSON_EXPORT SerializerRunnable  : public QObject, public QRunnable
+  {
+    Q_OBJECT
+    public:
+      /**
+      * This signal is emitted when the conversion process has been completed
+      * @param data contains the JSON data that has to be converted
+      * @param parent parent of the object
+      **/
+      explicit SerializerRunnable(QObject* parent = 0);
+      ~SerializerRunnable();
+
+      /**
+       * Sets the json object to serialize.
+       *
+       * @param json QVariant containing the json representation to be serialized
+       */
+      void setJsonObject( const QVariant& json );
+
+      /* reimp */ void run();
+
+    Q_SIGNALS:
+      /**
+      * This signal is emitted when the serialization process has been completed
+      * @param serialized contains the result of the serialization
+      * @param ok if a serialization error occurs ok is set to false, otherwise it's set to true.
+      * @param error_msg contains a string explaining the failure reason
+      **/
+      void parsingFinished(const QByteArray& serialized, bool ok, const QString& error_msg);
+
+    private:
+      Q_DISABLE_COPY(SerializerRunnable)
+      class Private;
+      Private* const d;
+  };
+}
+
+#endif // SERIALIZERRUNNABLE_H
diff --git a/WebCore/platform/graphics/embedded/qjson/stack.hh b/WebCore/platform/graphics/embedded/qjson/stack.hh
new file mode 100644
index 0000000..754b664
--- /dev/null
+++ b/WebCore/platform/graphics/embedded/qjson/stack.hh
@@ -0,0 +1,129 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Stack handling for Bison parsers in C++
+
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef BISON_STACK_HH
+# define BISON_STACK_HH
+
+#include <deque>
+
+namespace yy
+{
+  template <class T, class S = std::deque<T> >
+  class stack
+  {
+  public:
+
+    // Hide our reversed order.
+    typedef typename S::reverse_iterator iterator;
+    typedef typename S::const_reverse_iterator const_iterator;
+
+    stack () : seq_ ()
+    {
+    }
+
+    stack (unsigned int n) : seq_ (n)
+    {
+    }
+
+    inline
+    T&
+    operator [] (unsigned int i)
+    {
+      return seq_[i];
+    }
+
+    inline
+    const T&
+    operator [] (unsigned int i) const
+    {
+      return seq_[i];
+    }
+
+    inline
+    void
+    push (const T& t)
+    {
+      seq_.push_front (t);
+    }
+
+    inline
+    void
+    pop (unsigned int n = 1)
+    {
+      for (; n; --n)
+	seq_.pop_front ();
+    }
+
+    inline
+    unsigned int
+    height () const
+    {
+      return seq_.size ();
+    }
+
+    inline const_iterator begin () const { return seq_.rbegin (); }
+    inline const_iterator end () const { return seq_.rend (); }
+
+  private:
+
+    S seq_;
+  };
+
+  /// Present a slice of the top of a stack.
+  template <class T, class S = stack<T> >
+  class slice
+  {
+  public:
+
+    slice (const S& stack,
+	   unsigned int range) : stack_ (stack),
+				 range_ (range)
+    {
+    }
+
+    inline
+    const T&
+    operator [] (unsigned int i) const
+    {
+      return stack_[range_ - i];
+    }
+
+  private:
+
+    const S& stack_;
+    unsigned int range_;
+  };
+}
+
+#endif // not BISON_STACK_HH
diff --git a/WebCore/platform/network/qt/ResourceHandleQt.cpp b/WebCore/platform/network/qt/ResourceHandleQt.cpp
index aaa306a..8356ae0 100644
--- a/WebCore/platform/network/qt/ResourceHandleQt.cpp
+++ b/WebCore/platform/network/qt/ResourceHandleQt.cpp
@@ -203,7 +203,9 @@ void ResourceHandle::loadResourceSynchronously(const ResourceRequest& request, S
     d->m_frame = static_cast<FrameLoaderClientQt*>(frame->loader()->client())->webFrame();
     d->m_job = new QNetworkReplyHandler(&handle, QNetworkReplyHandler::LoadNormal);
 
-    syncLoader.waitForCompletion();
+    // If there was no reply, don't wait for completion!
+    if (d->m_job->reply())
+        syncLoader.waitForCompletion();
     error = syncLoader.resourceError();
     data = syncLoader.data();
     response = syncLoader.resourceResponse();
diff --git a/WebCore/plugins/PluginDatabase.cpp b/WebCore/plugins/PluginDatabase.cpp
index b09658f..63c60d8 100644
--- a/WebCore/plugins/PluginDatabase.cpp
+++ b/WebCore/plugins/PluginDatabase.cpp
@@ -27,8 +27,10 @@
 #include "config.h"
 #include "PluginDatabase.h"
 
+#include "CString.h"
 #include "Frame.h"
 #include "KURL.h"
+#include "Logging.h"
 #include "PluginDatabaseClient.h"
 #include "PluginPackage.h"
 #include <stdlib.h>
@@ -331,7 +333,7 @@ Vector<String> PluginDatabase::defaultPluginDirectories()
     Vector<String> paths;
 
     // Add paths specific to each platform
-#if defined(XP_UNIX)
+#if defined(XP_UNIX) || defined(XP_EMBEDDED)
     String userPluginPath = homeDirectoryPath();
     userPluginPath.append(String("/.mozilla/plugins"));
     paths.append(userPluginPath);
@@ -386,6 +388,10 @@ Vector<String> PluginDatabase::defaultPluginDirectories()
     paths.append(qtPaths);
 #endif
 
+    for(Vector<String>::iterator it = paths.begin(); it != paths.end(); ++it) {
+        LOG(Plugins, "PluginDatabase::defaultDirectories: %s", (*it).latin1().data());
+    }
+
     return paths;
 }
 
@@ -393,7 +399,7 @@ bool PluginDatabase::isPreferredPluginDirectory(const String& path)
 {
     String preferredPath = homeDirectoryPath();
 
-#if defined(XP_UNIX)
+#if defined(XP_UNIX) || defined(XP_EMBEDDED)
     preferredPath.append(String("/.mozilla/plugins"));
 #elif defined(XP_MACOSX)
     preferredPath.append(String("/Library/Internet Plug-Ins"));
@@ -410,7 +416,7 @@ void PluginDatabase::getPluginPathsInDirectories(HashSet<String>& paths) const
     // FIXME: This should be a case insensitive set.
     HashSet<String> uniqueFilenames;
 
-#if defined(XP_UNIX)
+#if defined(XP_UNIX) || defined(XP_EMBEDDED)
     String fileNameFilter("*.so");
 #else
     String fileNameFilter("");
diff --git a/WebCore/plugins/PluginPackage.cpp b/WebCore/plugins/PluginPackage.cpp
index 3881f54..7ebbb94 100644
--- a/WebCore/plugins/PluginPackage.cpp
+++ b/WebCore/plugins/PluginPackage.cpp
@@ -301,6 +301,11 @@ void PluginPackage::initializeBrowserFuncs()
     m_browserFuncs.setexception = _NPN_SetException;
     m_browserFuncs.enumerate = _NPN_Enumerate;
     m_browserFuncs.construct = _NPN_Construct;
+
+#ifdef XP_EMBEDDED
+    m_browserFuncs.scheduletimer = NPN_ScheduleTimer;
+    m_browserFuncs.unscheduletimer = NPN_UnscheduleTimer;
+#endif
 }
 #endif
 
diff --git a/WebCore/plugins/PluginTimer.cpp b/WebCore/plugins/PluginTimer.cpp
new file mode 100644
index 0000000..63a83ec
--- /dev/null
+++ b/WebCore/plugins/PluginTimer.cpp
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2006, 2007, 2008 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "PluginTimer.h"
+
+namespace WebCore {
+
+    static uint32 gTimerID;
+
+    PluginTimer::PluginTimer(PluginTimer** list, NPP instance, bool repeat, void (*timerFunc)(NPP npp, uint32 timerID))
+        : m_list(list)
+        , m_instance(instance)
+        , m_timerFunc(timerFunc)
+        , m_repeat(repeat)
+    {
+        m_timerID = ++gTimerID;
+
+        m_next = *list;
+        if (m_next)
+            m_next->m_prev = this;
+
+        m_prev = 0;
+        *list = this;
+    }
+
+    PluginTimer::~PluginTimer()
+    {
+        if (m_next)
+            m_next->m_prev = m_prev;
+
+        if (m_prev)
+            m_prev->m_next = m_next;
+        else
+            *m_list = m_next;
+    }
+
+    void PluginTimer::fired()
+    {
+        m_timerFunc(m_instance, m_timerID);
+        if (!m_repeat)
+            delete this;
+    }
+
+    // may return null if timerID is not found
+    PluginTimer* PluginTimer::find(PluginTimer* list, uint32 timerID)
+    {
+        PluginTimer* curr = list;
+        while (curr) {
+            if (curr->m_timerID == timerID)
+                break;
+            curr = curr->m_next;
+        }
+        return curr;
+    }
+
+    PluginTimerList::~PluginTimerList()
+    {
+        while (m_list)
+            delete m_list;
+    }
+
+    uint32 PluginTimerList::schedule(NPP instance, uint32 interval, bool repeat,
+                                     void (*proc)(NPP npp, uint32 timerID))
+    {
+        PluginTimer* timer = new PluginTimer(&m_list, instance, repeat, proc);
+
+        double dinterval = interval * 0.001;    // milliseconds to seconds
+        if (repeat)
+            timer->startRepeating(dinterval);
+        else
+            timer->startOneShot(dinterval);
+        return timer->timerID();
+    }
+
+    void PluginTimerList::unschedule(NPP instance, uint32 timerID)
+    {
+        delete PluginTimer::find(m_list, timerID);
+    }
+
+} // namespace WebCore
diff --git a/WebCore/plugins/PluginTimer.h b/WebCore/plugins/PluginTimer.h
new file mode 100644
index 0000000..8ee44a1
--- /dev/null
+++ b/WebCore/plugins/PluginTimer.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2006, 2007, 2008 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef PluginTimer_h
+#define PluginTimer_h
+
+#include "Timer.h"
+#include "npapi.h"
+
+namespace WebCore {
+
+    class PluginTimerList;
+
+    class PluginTimer : public TimerBase {
+    public:
+        PluginTimer(PluginTimer** list, NPP instance, bool repeat, void (*proc)(NPP npp, uint32 timerID));
+        virtual ~PluginTimer();
+
+        uint32 timerID() const { return m_timerID; }
+
+        static PluginTimer* find(PluginTimer* list, uint32 timerID);
+
+    private:
+        // override from TimerBase
+        virtual void fired();
+
+        PluginTimer* next() const { return m_next; }
+        friend class PluginTimerList;
+
+        PluginTimer**   m_list;
+        PluginTimer*    m_prev;
+        PluginTimer*    m_next;
+        NPP             m_instance;
+        void            (*m_timerFunc)(NPP, uint32);
+        uint32          m_timerID;
+        bool            m_repeat;
+    };
+
+    class PluginTimerList {
+    public:
+        PluginTimerList() : m_list(0) {}
+        ~PluginTimerList();
+
+        uint32 schedule(NPP instance, uint32 interval, bool repeat,
+                        void (*proc)(NPP npp, uint32 timerID));
+        void unschedule(NPP instance, uint32 timerID);
+
+    private:
+        PluginTimer* m_list;
+    };
+
+} // namespace WebCore
+
+#endif // PluginTimer_h
diff --git a/WebCore/plugins/PluginView.cpp b/WebCore/plugins/PluginView.cpp
index b8b2f2f..3f4fe99 100644
--- a/WebCore/plugins/PluginView.cpp
+++ b/WebCore/plugins/PluginView.cpp
@@ -127,6 +127,7 @@ IntRect PluginView::windowClipRect() const
 
 void PluginView::setFrameRect(const IntRect& rect)
 {
+    LOG(Plugins, "PluginView::setFrameRect(%d, %d, %d, %d)", rect.x(), rect.y(), rect.width(), rect.height());
     if (m_element->document()->printing())
         return;
 
@@ -142,6 +143,8 @@ void PluginView::setFrameRect(const IntRect& rect)
     // On Unix, multiple calls to setNPWindow() in windowed mode causes Flash to crash
     if (m_mode == NP_FULL || !m_isWindowed)
         setNPWindowRect(rect);
+#elif defined(XP_EMBEDDED)
+    setNPWindowRect(rect);
 #endif
 }
 
@@ -217,6 +220,7 @@ bool PluginView::startOrAddToUnstartedList()
 
 bool PluginView::start()
 {
+    LOG(Plugins, "PluginView::start()");
     if (m_isStarted)
         return false;
 
@@ -627,10 +631,11 @@ void PluginView::status(const char* message)
 
 NPError PluginView::setValue(NPPVariable variable, void* value)
 {
-    LOG(Plugins, "PluginView::setValue(%s): ", prettyNameForNPPVariable(variable, value).data());
+  LOG(Plugins, "PluginView::setValue(%s): ", prettyNameForNPPVariable(variable, value).data());
 
     switch (variable) {
     case NPPVpluginWindowBool:
+      LOG(Plugins, "   m_isWindowed = %d", (int)value);
         m_isWindowed = value;
         return NPERR_NO_ERROR;
     case NPPVpluginTransparentBool:
@@ -685,7 +690,12 @@ NPError PluginView::setValue(NPPVariable variable, void* value)
         m_renderToImage = true;
         return NPERR_NO_ERROR;
 #endif
+#ifdef XP_EMBEDDED
+    case NPPVpluginWindowSize:
+        return platformSetValue(variable, value);
+#endif
 
+ 
     default:
         notImplemented();
         return NPERR_GENERIC_ERROR;
@@ -712,6 +722,16 @@ void PluginView::popPopupsEnabledState()
     m_popupStateStack.removeLast();
 }
 
+uint32 PluginView::scheduleTimer(uint32 interval, bool repeat, void (*timerFunc)(NPP, uint32 timerID))
+{
+    return m_timers.schedule(instance(), interval, repeat, timerFunc);
+}
+
+void PluginView::unscheduleTimer(uint32 timerID)
+{
+    m_timers.unschedule(instance(), timerID);
+}
+
 bool PluginView::arePopupsAllowed() const
 {
     if (!m_popupStateStack.isEmpty())
@@ -825,7 +845,7 @@ PluginView::PluginView(Frame* parentFrame, const IntSize& size, PluginPackage* p
     , m_paramNames(0)
     , m_paramValues(0)
     , m_mimeType(mimeType)
-#if defined(XP_MACOSX)
+#if 1 // defined(XP_MACOSX)
     , m_isWindowed(false)
 #else
     , m_isWindowed(true)
@@ -867,12 +887,23 @@ PluginView::PluginView(Frame* parentFrame, const IntSize& size, PluginPackage* p
     , m_isJavaScriptPaused(false)
     , m_isHalted(false)
     , m_hasBeenHalted(false)
+    , m_isFullscreen(false)
+    , m_isFakeFullscreen(false)
+    , m_actualFullscreen(false)
+    , m_fullscreenByPlugin(false)
+    , m_sentWindowEvent(false)
 {
+    LOG(Plugins, "PluginView::PluginView()");
     if (!m_plugin) {
+        LOG(Plugins, "PluginView::PluginView() CanNotFundPlugin!");
         m_status = PluginStatusCanNotFindPlugin;
         return;
     }
 
+    // Boxee:
+    // sendinf NP_FULL causes issues with flash which expects to have a window at that point
+    m_mode = NP_EMBED;
+
     m_instance = &m_instanceStruct;
     m_instance->ndata = this;
     m_instance->pdata = 0;
@@ -1205,6 +1236,7 @@ NPError PluginView::handlePost(const char* url, const char* target, uint32 len,
 
 void PluginView::invalidateWindowlessPluginRect(const IntRect& rect)
 {
+//    LOG(Plugins, "PluginView::invalidateWindowlessPluginRect(%d, %d, %d, %d)", rect.x(), rect.y(), rect.width(), rect.height());
     if (!isVisible())
         return;
     
@@ -1214,6 +1246,7 @@ void PluginView::invalidateWindowlessPluginRect(const IntRect& rect)
     
     IntRect dirtyRect = rect;
     dirtyRect.move(renderer->borderLeft() + renderer->paddingLeft(), renderer->borderTop() + renderer->paddingTop());
+//    LOG(Plugins, "PluginView::invalidateWindowlessPluginRect() ACTUALLY REPAINTING");
     renderer->repaintRectangle(dirtyRect);
 }
 
@@ -1331,8 +1364,10 @@ NPError PluginView::getValue(NPNVariable variable, void* value)
 
     switch (variable) {
     case NPNVWindowNPObject: {
-        if (m_isJavaScriptPaused)
+        if (m_isJavaScriptPaused) {
+            LOG(Plugins, "PluginView::getValue(NPNVWindowNPObject) JAVASCRIPT IS PAUSED!");
             return NPERR_GENERIC_ERROR;
+        }
 
         NPObject* windowScriptObject = m_parentFrame->script()->windowScriptNPObject();
 
@@ -1394,4 +1429,17 @@ void PluginView::privateBrowsingStateChanged(bool privateBrowsingEnabled)
     PluginView::setCurrentPluginView(0);
 }
 
+#ifndef XP_EMBEDDED
+void PluginView::showFullscreen(bool isFullscreen, bool fakeFullscreen, bool fullscreenByPlugin)
+{
+    m_isFullscreen = isFullscreen;
+    m_isFakeFullscreen = fakeFullscreen;
+}
+
+void PluginView::handleEvent(QEvent*)
+{
+}
+#endif
+
+
 } // namespace WebCore
diff --git a/WebCore/plugins/PluginView.h b/WebCore/plugins/PluginView.h
index f346134..a254606 100644
--- a/WebCore/plugins/PluginView.h
+++ b/WebCore/plugins/PluginView.h
@@ -34,6 +34,7 @@
 #include "IntRect.h"
 #include "MediaCanStartListener.h"
 #include "PluginStream.h"
+#include "PluginTimer.h"
 #include "ResourceRequest.h"
 #include "Timer.h"
 #include "Widget.h"
@@ -154,6 +155,8 @@ namespace WebCore {
         void forceRedraw();
         void pushPopupsEnabledState(bool state);
         void popPopupsEnabledState();
+        uint32 scheduleTimer(uint32 interval, bool repeat, void (*timerFunc)(NPP instance, uint32 timerID));
+        void unscheduleTimer(uint32 timerID);
 
         virtual void invalidateRect(const IntRect&);
 
@@ -180,6 +183,7 @@ namespace WebCore {
         IntRect windowClipRect() const;
 
         virtual void handleEvent(Event*);
+        virtual void handleEvent(QEvent*);
         virtual void setParent(ScrollView*);
         virtual void setParentVisible(bool);
 
@@ -224,6 +228,12 @@ namespace WebCore {
 #endif
         void keepAlive();
 
+        void showFullscreen(bool isFullscreen, bool fakeFullScreen=true, bool fullscreenByPlugin = false);
+
+#ifdef XP_EMBEDDED
+        IntRect fullScreenInvalidRect() { return m_fullScreenInvalidRect; }
+#endif
+
     private:
         PluginView(Frame* parentFrame, const IntSize&, PluginPackage*, Element*, const KURL&, const Vector<String>& paramNames, const Vector<String>& paramValues, const String& mimeType, bool loadManually);
 
@@ -254,6 +264,11 @@ namespace WebCore {
         static bool platformGetValueStatic(NPNVariable variable, void* value, NPError* result);
         bool platformGetValue(NPNVariable variable, void* value, NPError* result);
 
+#ifdef XP_EMBEDDED
+        NPError platformSetValue(NPPVariable variable, void* value);
+        void sendFullscreenEventToPlugin();
+#endif
+
         RefPtr<Frame> m_parentFrame;
         RefPtr<PluginPackage> m_plugin;
         Element* m_element;
@@ -263,6 +278,11 @@ namespace WebCore {
         PluginStatus m_status;
         Vector<IntRect> m_invalidRects;
 
+#ifdef XP_EMBEDDED
+        IntRect m_fullScreenInvalidRect;
+        bool m_shouldClearFullscreen;
+#endif
+
         void performRequest(PluginRequest*);
         void scheduleRequest(PluginRequest*);
         void requestTimerFired(Timer<PluginView>*);
@@ -289,6 +309,8 @@ namespace WebCore {
         void handleFocusOutEvent();
 #endif
 
+        bool event(QEvent*);
+
 #if OS(WINDOWS)
         void paintIntoTransformedContext(HDC);
         PassRefPtr<Image> snapshot();
@@ -312,6 +334,8 @@ namespace WebCore {
         HashSet<RefPtr<PluginStream> > m_streams;
         Vector<PluginRequest*> m_requests;
 
+        PluginTimerList m_timers;
+
         bool m_isWindowed;
         bool m_isTransparent;
         bool m_haveInitialized;
@@ -330,7 +354,7 @@ namespace WebCore {
         bool m_haveUpdatedPluginWidget;
 #endif
 
-#if ((PLATFORM(QT) || PLATFORM(WX)) && OS(WINDOWS)) || defined(XP_MACOSX)
+#if ((PLATFORM(QT) || PLATFORM(WX)) && OS(WINDOWS)) || defined(XP_MACOSX) || defined(XP_EMBEDDED)
         // On Mac OSX and Qt/Windows the plugin does not have its own native widget,
         // but is using the containing window as its reference for positioning/painting.
         PlatformPluginWidget m_window;
@@ -392,6 +416,12 @@ private:
         bool m_isHalted;
         bool m_hasBeenHalted;
 
+        bool m_isFullscreen;
+        bool m_isFakeFullscreen;
+        bool m_actualFullscreen;
+        bool m_fullscreenByPlugin;
+        bool m_sentWindowEvent;
+
         static PluginView* s_currentPluginView;
     };
 
diff --git a/WebCore/plugins/embedded/PluginEvents.h b/WebCore/plugins/embedded/PluginEvents.h
new file mode 100644
index 0000000..2d41d0b
--- /dev/null
+++ b/WebCore/plugins/embedded/PluginEvents.h
@@ -0,0 +1,124 @@
+#ifndef PluginEventsSDL_h
+#define PluginEventsSDL_h
+
+
+typedef enum PluginEventType_e
+{
+	PluginMouseEventType,
+	PluginKeyEventType,
+	PluginPaintEventType
+}PluginEventType;
+
+typedef enum PluginMouseState_e
+{
+	PluginMouseButtonDown,
+	PluginMouseButtonUp,
+	PluginMouseButtonMove
+}PluginMouseState;
+
+typedef enum PluginMouseButton_e
+{
+	PluginMouseButtonLeft,
+	PluginMouseButtonCenter,
+	PluginMouseButtonRight,
+	PluginMouseButtonWheelUp,
+	PluginMouseButtonWheelDown
+}PluginMouseButton;
+
+typedef enum PluginKeyState_e
+{
+	PluginKeyDown,
+	PluginKeyUp
+}PluginKeyState;
+
+typedef enum PluginModifierKey_e
+{
+	PluginAltKey 		= 1 << 0,
+	PluginCtrlKey 		= 1 << 1,
+	PluginMetaKey 		= 1 << 2,
+	PluginShiftKey 		= 1 << 3,
+}PluginModifierKey;
+
+
+typedef struct PluginRect_s
+{
+    int16_t		top;
+    int16_t		left;
+    int16_t		bottom;
+    int16_t		right;
+} PluginRect;
+
+typedef struct
+{
+	uint8_t 			type;
+	uint8_t 			state;
+	uint16_t 			x;
+	uint16_t			y;
+	int16_t 			xrel;
+	int16_t				yrel;
+	uint8_t 			which;
+	uint8_t 			button;
+} PluginMouseEvent;
+
+typedef struct
+{
+	uint8_t 			type;
+	uint8_t 			state;
+	uint8_t 			scancode;
+	uint16_t 			sym;
+	uint16_t 			mod;
+	uint16_t 			unicode;
+} PluginKeyEvent;
+
+typedef struct
+{
+	uint8_t 			type;
+	uint8_t				bUseAccelBlit;
+	PluginRect 			inval;
+	uint16_t 			w;
+	uint16_t			h;
+	uint16_t 			xoffset;
+	uint16_t			yoffset;
+	uint16_t 			pitch;
+	uint8_t 			depth;
+	uint8_t* 			pixels;
+} PluginPaintEvent;
+
+typedef union
+{
+	uint8_t				type;
+	PluginMouseEvent	mouse;
+	PluginKeyEvent		key;
+	PluginPaintEvent	paint;
+} PluginEvent;
+
+
+// Extend the NPNVariable enumeration
+#define NPPVpluginDrawingFunctions	9999
+
+typedef void* 	(*CREATE_SURFACE_FUNC)		(int width, int height, int depth_in_bits);
+typedef bool 	(*FREE_SURFACE_FUNC)		(void * pSurface);
+typedef bool 	(*LOCK_SURFACE_FUNC)		(void * pSurface);
+typedef bool 	(*UNLOCK_SURFACE_FUNC)		(void * pSurface);
+typedef void* 	(*GET_PIXELS_FUNC)			(void * pSurface);
+typedef int 	(*GET_PITCH_FUNC)			(void * pSurface);
+typedef bool 	(*DRAW_RECT_FUNC)			(void * pSurface, uint32_t color, const PluginRect* rect);
+typedef bool 	(*BLIT_FUNC)				(void * pSurface, void* pTargetSurface, const int nTargetPitch, const PluginRect* src_rect,
+											 const PluginRect* dest_rect, bool bSourceAlpha);
+
+typedef struct GL_FuncTable_s
+{
+	CREATE_SURFACE_FUNC		pfCreateSurface;
+	FREE_SURFACE_FUNC		pfFreeSurface;
+	LOCK_SURFACE_FUNC		pfLockSurface;
+	UNLOCK_SURFACE_FUNC		pfUnlockSurface;
+	GET_PIXELS_FUNC			pfGetPixels;
+	GET_PITCH_FUNC			pfGetPitch;
+	DRAW_RECT_FUNC			pfDrawRect;
+	BLIT_FUNC				pfBlit;
+} GL_FuncTable;
+
+
+
+
+#endif // PluginEventsSDL_h
diff --git a/WebCore/plugins/embedded/PluginViewEmbedded.cpp b/WebCore/plugins/embedded/PluginViewEmbedded.cpp
new file mode 100644
index 0000000..c4f12c3
--- /dev/null
+++ b/WebCore/plugins/embedded/PluginViewEmbedded.cpp
@@ -0,0 +1,931 @@
+/*
+* Copyright (C) 2006, 2007 Apple Inc.  All rights reserved.
+* Copyright (C) 2008 Collabora Ltd. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+*    notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+*    notice, this list of conditions and the following disclaimer in the
+*    documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
+* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+* PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
+* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "config.h"
+#include "PluginView.h"
+#include "PluginEvents.h"
+
+#include "Document.h"
+#include "DocumentLoader.h"
+#include "Element.h"
+#include "EventNames.h"
+#include "FocusController.h"
+#include "FrameLoader.h"
+#include "FrameLoadRequest.h"
+#include "FrameTree.h"
+#include "Frame.h"
+#include "FrameView.h"
+#include "GraphicsContext.h"
+#include "Image.h"
+#include "HTMLNames.h"
+#include "HTMLPlugInElement.h"
+#include "KeyboardEvent.h"
+#include "MouseEvent.h"
+#include "NotImplemented.h"
+#include "Page.h"
+#include "PlatformKeyboardEvent.h"
+#include "PlatformMouseEvent.h"
+#include "PluginDebug.h"
+#include "PluginPackage.h"
+#include "RenderLayer.h"
+#include "Settings.h"
+#include "JSDOMBinding.h"
+#include "ScriptController.h"
+#include "npruntime_impl.h"
+//#include "runtime.h"
+//#include "runtime_root.h"
+
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+
+#include <QPainter>
+#include <QImage>
+#include <QScreen>
+#include <QMouseEvent>
+
+#include <runtime/JSLock.h>
+
+// These methods are used to detect that the plugin is
+// showing full screen because of USER INTERACTION,
+// not because of a call to BoxeePluginWidget::SetFullScreen.
+
+//static bool s_bIsFullScreen = false;
+//static void* s_pPluginView = NULL;
+
+//bool GetBrowserSize(int* width, int* height)
+//{
+//  *width = QScreen::instance()->width();
+//  *height = QScreen::instance()->height();
+//  return true;
+//}
+
+//bool GetBrowserOffsets(int* offsetX, int* offsetY)
+//{
+//  *offsetX = 0;
+//  *offsetY = 0;
+//}
+
+//bool GetBrowserPluginFullscreen(void** pluginView)
+//{
+//  *pluginView = s_pPluginView;
+//  return s_bIsFullScreen;
+//}
+
+//bool SetBrowserPluginFullscreen(void* pluginView, bool isFullScreen)
+//{
+//  isFullScreen = s_bIsFullScreen;
+//  pluginView = s_pPluginView;
+//  return true;
+//}
+//bool GetBrowserSize(int* width, int* height)
+//{
+//  *width = QScreen::instance()->width();
+//  *height = QScreen::instance()->height();
+//  return true;
+//}
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+  extern bool GetBrowserOffsets(int* offsetX, int* offsetY);
+  extern bool GetBrowserPluginFullscreen(void** pluginView);
+  extern bool SetBrowserPluginFullscreen(void* pluginView, bool isFullScreen);
+  extern bool GetBrowserSize(int* width, int* height);
+#ifdef __cplusplus
+} // extern C
+#endif
+
+
+#define TRACE_INFO fprintf
+#define TRACE_DEBUG(...)
+
+
+using JSC::ExecState;
+using JSC::Interpreter;
+using JSC::JSObject;
+using JSC::UString;
+
+using std::min;
+
+using namespace WTF;
+
+
+namespace WebCore {
+
+// If you want to use SDL as the accellerated drawing framework,
+// here's how it could look. You could also create your own
+// version that uses DirectFB.
+#ifdef ENABLE_SDL
+static void* GLCreateSurface(int width, int height, int depth)
+{
+    int flagsSdlWindow  = SDL_HWSURFACE;
+    void* surface  = 0;
+
+    surface = (void*)SDL_CreateRGBSurface(flagsSdlWindow, width, height, depth, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000);
+    if (surface) {
+        LOG(Plugins, "GLCreateSurface Unable to create screen : %s\n", SDL_GetError() );
+    }
+
+    printf("OWB: creating plugin backing store using GLCreateSurface surface = %X\n", (unsigned int)surface);
+
+    return surface;
+}
+static bool GLFreeSurface(void * pSurface)
+{
+    // printf("OWB: GLFreeSurface\n");
+    SDL_FreeSurface((SDL_Surface*)pSurface);
+    return TRUE;
+}
+static bool GLLockSurface(void * pSurface)
+{
+    // printf("OWB: GLLockSurface\n");
+    SDL_LockSurface((SDL_Surface*)pSurface);
+    return TRUE;
+}
+static bool GLUnlockSurface(void * pSurface)
+{
+    // printf("OWB: GLUnlockSurface\n");
+    SDL_UnlockSurface((SDL_Surface*)pSurface);
+    return TRUE;
+}
+static void* GLGetPixels(void * pSurface)
+{
+    // printf("OWB: GLGetPixels\n");
+    return ((SDL_Surface*)pSurface)->pixels;
+}
+static int GLGetPitch(void * pSurface)
+{
+    // printf("OWB: GLGetPitch\n");
+    return ((SDL_Surface*)pSurface)->pitch;
+}
+static bool GLDrawRect(void * pSurface, uint32_t color, const PluginRect* rect)
+{
+    // printf("OWB: GLDrawRect\n");
+    return TRUE;
+}
+static bool GLBlit(void * pSurface, void* pTargetSurface, const int nTargetPitch, const PluginRect* src_rect,
+                   const PluginRect* dest_rect, bool bSourceAlpha)
+{
+    // printf("OWB: GLBlit surface = %X, target = %X\n", (uint32_t)pSurface, (uint32_t)pTargetSurface);
+    if(bSourceAlpha) {
+        SDL_SetAlpha((SDL_Surface*)pSurface, SDL_SRCALPHA, SDL_ALPHA_TRANSPARENT);
+    }
+
+    SDL_Rect srcRect = {src_rect->left, src_rect->top, src_rect->right - src_rect->left, src_rect->bottom - src_rect->top };
+    SDL_Rect destRect = { dest_rect->left, dest_rect->top, dest_rect->right - dest_rect->left, dest_rect->bottom - dest_rect->top };
+    SDL_LowerBlit((SDL_Surface*)pSurface, &srcRect, (SDL_Surface*)pTargetSurface, &destRect);
+
+    return TRUE;
+}
+bool GLGetFuncs(GL_FuncTable **table)
+{
+    static GL_FuncTable drawingFuncs = { 0, 0, 0, 0, 0, 0, 0, 0 };
+
+    if(!drawingFuncs.pfCreateSurface) {
+        bool bUseAcceleratedPluginBlit = FALSE;
+        // Get the blit acceleration status from environment variable
+        String strUseBlitAccel(getenv("PLUGIN_USE_ACCEL_BLIT"));
+        if(strUseBlitAccel.contains("true")) {
+            LOG(Plugins, "PluginView::paint using acclerated blit\n");
+            bUseAcceleratedPluginBlit = TRUE;
+        }
+        else {
+            LOG(Plugins, "PluginView::paint using memory drawing functions\n");
+        }
+
+        if(bUseAcceleratedPluginBlit == TRUE) {
+            drawingFuncs.pfCreateSurface = GLCreateSurface;
+            drawingFuncs.pfFreeSurface  = GLFreeSurface;
+            drawingFuncs.pfLockSurface  = GLLockSurface;
+            drawingFuncs.pfUnlockSurface = GLUnlockSurface;
+            drawingFuncs.pfGetPixels  = GLGetPixels;
+            drawingFuncs.pfGetPitch   = GLGetPitch;
+            drawingFuncs.pfDrawRect   = GLDrawRect;
+            drawingFuncs.pfBlit    = GLBlit;
+        }
+    }
+    if(drawingFuncs.pfCreateSurface == NULL) {
+        *table = NULL;
+        return FALSE;
+    }
+    else {
+        *table = &drawingFuncs;
+        return TRUE;
+    }
+}
+#else
+bool GLGetFuncs(GL_FuncTable** table) { return false; }
+#endif
+
+void PluginView::updatePluginWidget()
+{
+    // Sync state with the containing frame view
+    if (!parent() || !m_isWindowed)
+        return;
+
+    ASSERT(parent()->isFrameView());
+    FrameView* frameView = static_cast<FrameView*>(parent());
+
+    IntRect oldWindowRect = m_windowRect;
+    IntRect oldClipRect = m_clipRect;
+
+    m_windowRect = IntRect(frameView->contentsToWindow(frameRect().location()), frameRect().size());
+    m_clipRect = windowClipRect();
+    m_clipRect.move(-m_windowRect.x(), -m_windowRect.y());
+}
+
+void PluginView::setFocus()
+{
+    // Nothing to do here for our platform
+    Widget::setFocus();
+}
+
+void PluginView::show()
+{
+    LOG(Plugins, "PluginView::show\n");
+    setSelfVisible(true);
+
+    Widget::show();
+}
+
+void PluginView::hide()
+{
+    LOG(Plugins, "PluginView::hide\n");
+    setSelfVisible(false);
+
+    Widget::hide();
+}
+
+void PluginView::paint(GraphicsContext* context, const IntRect& rect)
+{
+  LOG(Plugins, "PluginView::paint %d, %d, %d, %d\n", rect.x(), rect.y(), rect.width(), rect.height());
+
+    if (!m_isStarted || m_status !=  PluginStatusLoadedSuccessfully) {
+        // Draw the "missing plugin" image
+        paintMissingPluginIcon(context, rect);
+        return;
+    }
+
+    IntRect scrollOffset(0,0,0,0);
+
+    PluginEvent event;
+    PluginView * pluginView = NULL;
+    memset(&event, 0, sizeof(PluginEvent));
+
+    // From BoxeeBrowser::requestRepaint, we know that the
+    // paint device is in fact a QImage.
+    QPainter* painter = 0;
+    QImage* image = 0;
+
+    // Are we using accelerated GL functions hosted by the browser?
+    GL_FuncTable *table = NULL;
+    GLGetFuncs(&table);     // Set the passed in surface/memory based on the result.
+    if(table != NULL) {
+        // Using internal GL functions
+        LOG(Plugins, "PluginView::paint() using internal GL functions");
+        event.paint.bUseAccelBlit = true;
+
+        // This can be any type of surface that is compatible with the
+        // GL_FuncTable functions. Here we're passing the QPainter*,
+        // so your GL funcs need to operate on a QPainter*.
+        event.paint.pixels = (uint8_t*)context->platformContext();
+    } else {
+        // Passing in a memory bitmap
+        LOG(Plugins, "PluginView::paint() using memory bitmap");
+        event.paint.bUseAccelBlit = false;
+
+        // From BoxeeBrowser::requestRepaint, we know that the
+        // paint device is in fact a QImage.
+        painter = context->platformContext();
+        image = static_cast<QImage*>(painter->device());
+        event.paint.pixels = (uint8_t*)image->bits();
+    }
+
+    for (WebCore::ScrollView* p = parent(); p; p = p->parent()) {
+        int x = scrollOffset.x();
+        int y = scrollOffset.y();
+        scrollOffset.setX(x + p->x() - p->scrollX());
+        scrollOffset.setY(y + p->y() - p->scrollY());
+    }
+
+    LOG(Plugins, "PluginView::paint scroll offset x -> %d, y -> %d\n", scrollOffset.x(), scrollOffset.y());
+
+    // There are three modes.
+    // 1. Normal mode, embedded in web page
+    // 2. Full screen because of user interaction
+    // 3. Full screen because of BoxeePluginWidget::ShowFullScreen.
+
+    // Are we running full screen because of USER INTERACTION?
+    // (e.g. clicking the full screen button on youtube)
+    IntRect invalRect(0,0,0,0);
+        // At this point, we could be in normal mode or BoxeePluginWidget::SetFullScreen
+    LOG(Plugins, "PluginView::paint Normal Mode");
+    IntRect rectWidget = frameRect();
+    event.type = PluginPaintEventType;
+    if (m_isFullscreen) {
+        event.paint.inval.left   = 0;
+        event.paint.inval.top   = 0;
+        event.paint.inval.right  = QScreen::instance()->width();
+        event.paint.inval.bottom  = QScreen::instance()->height();
+        event.paint.xoffset   = 0;
+        event.paint.yoffset   = 0;
+
+        if (painter && m_shouldClearFullscreen) {
+            painter->fillRect(QRect(QPoint(0, 0), QSize(image->size())), QColor(0,0,0,0));
+            m_shouldClearFullscreen = false;
+            m_fullScreenInvalidRect = IntRect(0, 0, event.paint.w, event.paint.h);
+        }
+    } else {
+
+        event.paint.inval.left   = rect.x() + scrollOffset.x();
+        event.paint.inval.top   = rect.y() + scrollOffset.y();
+        event.paint.inval.right  = event.paint.inval.left + rect.width();
+        event.paint.inval.bottom  = event.paint.inval.top + rect.height();
+        event.paint.xoffset   = rectWidget.x() + scrollOffset.x();
+        event.paint.yoffset   = rectWidget.y() + scrollOffset.y();
+    }
+
+    event.paint.w    = image->width();
+    event.paint.h    = image->height();
+
+    event.paint.pitch   = image->bytesPerLine();
+    event.paint.depth   = 4;
+
+    NPEvent pEvt    = &event; // NPEvent is typedef'd as void*
+
+    // Finally call into the plugin
+    PluginView::setCurrentPluginView(this);
+    JSC::JSLock::DropAllLocks dropAllLocks(JSC::SilenceAssertionsOnly);
+    setCallingPlugin(true);
+    m_plugin->pluginFuncs()->event(m_instance, pEvt);
+    setCallingPlugin(false);
+    PluginView::setCurrentPluginView(0);
+
+    TRACE_DEBUG(stderr, "m_isFakeFullscreen %d m_actualFullscreen %d m_isFullscreen %d m_fullscreenByPlugin %d w %d h %d\n",
+            m_isFakeFullscreen, m_actualFullscreen, m_isFullscreen, m_fullscreenByPlugin, image->width(), image->height());
+    if (!m_isFakeFullscreen && !m_fullscreenByPlugin && m_actualFullscreen != m_isFullscreen)
+    {
+      sendFullscreenEventToPlugin();
+    }
+    else if (!m_isFakeFullscreen && m_fullscreenByPlugin && m_actualFullscreen != m_isFullscreen)
+    {
+      m_actualFullscreen = m_isFullscreen;
+    }
+}
+
+void PluginView::sendFullscreenEventToPlugin()
+{
+  TRACE_INFO(stderr, "m_isFakeFullscreen %d m_actualFullscreen %d m_isFullscreen %d \n", m_isFakeFullscreen, m_actualFullscreen, m_isFullscreen);
+  PluginEvent evt;
+  memset(&evt, 0, sizeof(PluginEvent));
+  evt.type = PluginPaintEventType + 1; // hack. we dont have the constant yet...
+  NPEvent pEvt = &evt;
+
+  LOG(Plugins, "Sending Fullscreen Event\n");
+  TRACE_INFO(stderr, "before Sending Fullscreen Event\n");
+  setCallingPlugin(true);
+  m_sentWindowEvent = true;
+  bool ret = m_plugin->pluginFuncs()->event(m_instance, pEvt);
+  m_sentWindowEvent = false;
+  setCallingPlugin(false);
+  TRACE_INFO(stderr, "after Sending Fullscreen Event\n");
+
+  m_actualFullscreen = m_isFullscreen;
+}
+
+void PluginView::handleKeyboardEvent(KeyboardEvent* event)
+{
+    if (m_isWindowed)
+        return;
+
+    String key = event->keyEvent()->keyIdentifier();
+    if (key == "F1" || key == "F2" || key == "F3" || key == "F4" ||
+        key == "F5" || key == "F6" || key == "F7" || key == "F8" ||
+        key == "F9" || key == "F10" || key == "F11" || key == "F12") {
+        return;
+    }
+
+    PluginEvent evt;
+    memset(&evt, 0, sizeof(PluginEvent));
+    evt.type = PluginKeyEventType;
+
+    switch (event->keyEvent()->type()) {
+    case PlatformKeyboardEvent::RawKeyDown:
+        evt.key.state = PluginKeyDown;
+        break;
+    case PlatformKeyboardEvent::KeyUp:
+        evt.key.state = PluginKeyUp;
+        break;
+    default:
+        return;
+    }
+
+
+    QKeyEvent* qtKeyEvent = event->keyEvent()->qtEvent();
+    TRACE_DEBUG("qt key event unicode %d\n", qtKeyEvent->text().unicode()[0].unicode());
+
+    int charCode = (event)->charCode();
+    evt.key.scancode = event->keyCode();
+    evt.key.sym   = event->keyEvent()->windowsVirtualKeyCode();
+    evt.key.mod   = event->keyEvent()->modifiers();
+    if (evt.key.sym == 0 && evt.key.scancode == 0)
+      evt.key.scancode = evt.key.sym = qtKeyEvent->text().unicode()[0].unicode();
+    TRACE_INFO(stderr, "plugin keyboard event state %d scancode %d sym %d mod %d text '%s'' charCode %d\n",
+            (int)evt.key.state,
+            (int)evt.key.scancode,
+            (int)evt.key.sym,
+            (int)evt.key.mod,
+            ((QString)event->keyEvent()->keyIdentifier()).toAscii().data(),
+            charCode);
+    evt.key.unicode = evt.key.scancode;
+
+    NPEvent pEvt  = &evt;
+
+    LOG(Plugins, "Sending Keyboard Event\n");
+    PluginView::setCurrentPluginView(this);
+    JSC::JSLock::DropAllLocks dropAllLocks(JSC::SilenceAssertionsOnly);
+    setCallingPlugin(true);
+    bool ret = m_plugin->pluginFuncs()->event(m_instance, pEvt);
+    setCallingPlugin(false);
+    PluginView::setCurrentPluginView(0);
+    if (ret)
+        event->setDefaultHandled();
+}
+
+void PluginView::handleMouseEvent(MouseEvent* event)
+{
+    PluginEvent evt;
+    memset(&evt, 0, sizeof(PluginEvent));
+    evt.type = PluginMouseEventType;
+
+    int state = PluginMouseButtonMove;
+    if(event->type() == eventNames().mouseoverEvent) {
+        state = PluginMouseButtonMove;
+    }
+    else if(event->type() == eventNames().mousedownEvent) {
+        state = PluginMouseButtonDown;
+        if (Page* page = m_parentFrame->page())
+            page->focusController()->setFocusedFrame(m_parentFrame);
+        m_parentFrame->document()->setFocusedNode(m_element);
+    }
+    else if(event->type() == eventNames().mouseupEvent) {
+        state = PluginMouseButtonUp;
+    }
+    evt.mouse.state  = state;
+    evt.mouse.xrel  = 0;
+    evt.mouse.yrel  = 0;
+    evt.mouse.which  = 0; // Device index
+    evt.mouse.button = event->button();
+
+    IntRect scrollOffset(0,0,0,0);
+    IntPoint p(0,0);
+
+    //
+    // Don't modify the mouse position if we're full-screen.
+    //
+    PluginView* pluginView;
+    p = static_cast<FrameView*>(parent())->contentsToWindow(IntPoint(event->pageX(), event->pageY()));
+    for (WebCore::ScrollView* pt = parent();
+    pt; pt = pt->parent()) {
+        int x = scrollOffset.x();
+        int y = scrollOffset.y();
+        scrollOffset.setX(x + pt->x() - pt->scrollX());
+        scrollOffset.setY(y + pt->y() - pt->scrollY());
+    }
+    evt.mouse.x   = p.x() - frameRect().x() - scrollOffset.x();
+    evt.mouse.y   = p.y() - frameRect().y() - scrollOffset.y();
+
+    NPEvent pEvt  = &evt;
+
+    //    LOG(Plugins, "Sending Mouse Event state = %d, x,y = %d, %d\n", evt.mouse.state, evt.mouse.x, evt.mouse.y);
+    PluginView::setCurrentPluginView(this);
+    JSC::JSLock::DropAllLocks dropAllLocks(JSC::SilenceAssertionsOnly);
+    setCallingPlugin(true);
+    bool ret = m_plugin->pluginFuncs()->event(m_instance, pEvt);
+    setCallingPlugin(false);
+    PluginView::setCurrentPluginView(0);
+    if (ret)
+        event->setDefaultHandled();
+}
+
+void PluginView::setParent(ScrollView* parent)
+{
+    Widget::setParent(parent);
+
+    if (parent)
+        init();
+}
+
+void PluginView::setNPWindowRect(const IntRect& rect)
+{
+  LOG(Plugins, "PluginView::setNPWindowRect(%d, %d, %d, %d)", rect.x(), rect.y(), rect.width(), rect.height());
+  TRACE_INFO(stderr, "PluginView::setNPWindowRect(%d, %d, %d, %d)\n", rect.x(), rect.y(), rect.width(), rect.height());
+    if (!m_isStarted || !parent()) {
+        LOG(Plugins, "PluginView::setNPWindowRect() RETURNING WITHOUT DOING NOTHING");
+        return;
+    }
+
+    int offsetX = 0;
+    int offsetY = 0;
+
+    ::GetBrowserOffsets(&offsetX, &offsetY);
+
+    IntPoint p(0,0);
+
+    PluginView* pluginView;
+    if (!::GetBrowserPluginFullscreen((void**)&pluginView)) {
+        TRACE_INFO(stderr, " %s %d - not in full screen, translating rect location to content\n", __FUNCTION__, __LINE__);
+        p = static_cast<FrameView*>(parent())->contentsToWindow(rect.location());
+    }
+
+#if 0
+    if(m_npWindow.x == (p.x() + offsetX) &&
+       m_npWindow.y == (p.y() + offsetY) &&
+       m_npWindow.width == rect.width() &&
+       m_npWindow.height == rect.height()) {
+        // This is the same data as already exists
+        return;
+    }
+#endif
+    m_npWindow.x = p.x();
+    m_npWindow.y = p.y();
+
+    // Add in offset for browser window from screen origin
+    m_npWindow.x += offsetX;
+    m_npWindow.y += offsetY;
+
+    m_npWindow.width = rect.width();
+    m_npWindow.height = rect.height();
+
+    m_npWindow.clipRect.left = 0;
+    m_npWindow.clipRect.top = 0;
+    m_npWindow.clipRect.right = rect.width();
+    m_npWindow.clipRect.bottom = rect.height();
+
+    if (m_npWindow.width <= 0 || m_npWindow.height <= 0)
+        return;
+
+    if (m_plugin->pluginFuncs()->setwindow) {
+          TRACE_DEBUG(stderr, "%s %d - plugin has a window size callback\n", __FUNCTION__, __LINE__);
+#if 0
+          if (m_isFullscreen) {
+            TRACE_INFO(stderr, "%s %d - plugin was set to fullscreen\n", __FUNCTION__, __LINE__);
+            m_npWindow.x = 0;
+            m_npWindow.y = 0;
+            m_npWindow.width = QScreen::instance()->width();
+            m_npWindow.height = QScreen::instance()->height();
+            m_npWindow.clipRect.right = m_npWindow.width;
+            m_npWindow.clipRect.bottom = m_npWindow.height;
+            TRACE_INFO(stderr, "%s %d - set fullscreen to %d * %d\n", __FUNCTION__, __LINE__, m_npWindow.width, m_npWindow.height);
+            LOG(Plugins, "PluginView::setNPWindowRect() Going fullscreen %d, %d", m_npWindow.width, m_npWindow.height);
+        }
+#endif
+        PluginView::setCurrentPluginView(this);
+        JSC::JSLock::DropAllLocks dropAllLocks(JSC::SilenceAssertionsOnly);
+        setCallingPlugin(true);
+        m_plugin->pluginFuncs()->setwindow(m_instance, &m_npWindow);
+        setCallingPlugin(false);
+        PluginView::setCurrentPluginView(0);
+    }
+}
+
+void PluginView::invalidateRegion(NPRegion)
+{
+    notImplemented();
+}
+
+NPError PluginView::handlePostReadFile(Vector<char>& buffer, uint32 len, const char* buf)
+{
+    return NPERR_NO_ERROR;
+}
+
+// Used before the plugin view has been initialized properly, and as a
+// fallback for variables that do not require a view to resolve.
+bool PluginView::platformGetValueStatic(NPNVariable variable, void* value, NPError* out)
+{
+    LOG(Plugins, "PluginView::platformGetValueStatic(%s)", prettyNameForNPNVariable(variable).data());
+
+    switch (variable) {
+    case NPNVToolkit:
+        *static_cast<uint32*>(value) = 0;
+        *out = NPERR_NO_ERROR;
+        return true;
+
+    case NPNVjavascriptEnabledBool:
+        *static_cast<NPBool*>(value) = true;
+        *out = NPERR_NO_ERROR;
+        return true;
+
+
+    default:
+        *out = NPERR_GENERIC_ERROR;
+        return false;
+    }
+}
+
+bool PluginView::platformGetValue(NPNVariable variable, void* value, NPError* out)
+{
+    return false;
+}
+
+void PluginView::invalidateRect(const IntRect& r)
+{
+//    LOG(Plugins, "PluginView::invalidateRect(const IntRect&) %d, %d, %d, %d\n", r.x(), r.y(), r.width(), r.height());
+    ASSERT(!m_isWindowed); // We're not gonna be windowed in this port
+
+    // Windowless plugin
+    // No need to send an event this is generated by the invalidateWindowlessPluginRect call
+    invalidateWindowlessPluginRect(r);
+
+    // If the plugin is in FS mode then save the invalidate rectangle
+    PluginView * pluginView = 0;
+    if(::GetBrowserPluginFullscreen((void**)&pluginView) == true && pluginView) {
+        if(pluginView == this) {
+            // This is the plugin that is currently in FS
+            m_invalidRects.append(r);
+        }
+    }
+}
+
+void PluginView::invalidateRect(NPRect* rect)
+{
+    if (!rect) {
+//        LOG(Plugins, "PluginView::invalidateRect(NPRect*) NULL\n");
+        invalidate();
+        return;
+    }
+//    LOG(Plugins, "PluginView::invalidateRect(NPRect*) %d, %d, %d, %d\n", rect->left, rect->top, rect->right - rect->left, rect->bottom - rect->top);
+    IntRect r(rect->left, rect->top, rect->right - rect->left, rect->bottom - rect->top);
+    invalidateRect(r);
+}
+
+void PluginView::forceRedraw()
+{
+    LOG(Plugins, "PluginView::forceRedraw()");
+}
+
+bool PluginView::platformStart()
+{
+    LOG(Plugins, "PluginView::platformStart()");
+    ASSERT(m_isStarted);
+    ASSERT(m_status == PluginStatusLoadedSuccessfully);
+
+    LOG(Plugins, "PluginView::platformStart() 1");
+    if (m_plugin->pluginFuncs()->getvalue) {
+        /*PluginView::setCurrentPluginView(this);
+    setCallingPlugin(true);
+    m_plugin->pluginFuncs()->getvalue(m_instance, NPPVpluginNeedsXEmbed, &m_needsXEmbed);
+    setCallingPlugin(false);
+    PluginView::setCurrentPluginView(0);*/
+    }
+
+    if (m_isWindowed)
+        m_npWindow.type = NPWindowTypeWindow;
+    else {
+        m_npWindow.type = NPWindowTypeDrawable;
+        m_npWindow.window = 0;
+    }
+
+    LOG(Plugins, "PluginView::platformStart() 2");
+
+    //if (!(m_plugin->quirks().contains(PluginQuirkDeferFirstSetWindowCall)))
+    setNPWindowRect(frameRect());
+
+    setPlatformPluginWidget(0/*m_parentFrame->view()->hostWindow()->platformWindow()*/);
+
+    show();
+
+    // Set the Browser GL Drawing Funcs
+    if (m_plugin->pluginFuncs()->setvalue) {
+        GL_FuncTable *table = 0;
+        // Get the callback table
+        GLGetFuncs(&table);
+        if(table) {
+            LOG(Plugins, "PluginView::init sending browser hosted GL function to plugin\n");
+            m_plugin->pluginFuncs()->setvalue(m_instance, (NPNVariable)NPPVpluginDrawingFunctions, table);
+        }
+        else {
+            LOG(Plugins, "PluginView::init using plugin based memory drawing functions\n");
+        }
+    } else {
+        LOG(Plugins, "m_plugins()->pluginFuncs()->setvalue is NULL! Unable to inject browser hosted GL functions into plugin!");
+    }
+
+    return true;
+}
+
+void PluginView::platformDestroy()
+{
+}
+
+void PluginView::setParentVisible(bool visible)
+{
+    if (isParentVisible() == visible)
+        return;
+
+    Widget::setParentVisible(visible);
+}
+
+NPError PluginView::platformSetValue(NPPVariable variable, void* value)
+{
+    NPRect* rect = (NPRect*)value;
+    int width, height, x, y;
+    LOG(Plugins, "PluginView::setValue received NPPVpluginWindowSize event size(l,t,r,b) = %d, %d, %d, %d",
+           rect->left, rect->top, rect->right, rect->bottom);
+    TRACE_INFO(stderr, "%s %d - window size event [(l,t,r,b) = %d, %d, %d, %d] is full screen by plugin - %d\n",
+           __FUNCTION__, __LINE__, rect->left, rect->top, rect->right, rect->bottom, m_fullscreenByPlugin);
+    TRACE_INFO(stderr, "%s %d - window size event m_fullscreenByPlugin = %d, m_sentWindowEvent = %d\n",
+           __FUNCTION__, __LINE__, m_fullscreenByPlugin, m_sentWindowEvent);
+    // Is this the full screen?
+    ::GetBrowserSize(&width, &height);
+    ::GetBrowserOffsets(&x, &y);
+
+    if (!m_sentWindowEvent &&
+        width <= (rect->right - rect->left) && height <= (rect->bottom - rect->top)) {
+      LOG(Plugins, "PluginView::setValue set FULLSCREEN mode to ON\n");
+      ::SetBrowserPluginFullscreen(this, true);
+      showFullscreen(!m_isFullscreen, false, true);
+      setNPWindowRect(IntRect(x,y,640,480));          
+    } else {
+        LOG(Plugins, "PluginView::setValue set FULLSCREEN mode to OFF");
+        if (m_fullscreenByPlugin)
+            showFullscreen(false, false, true);
+        if (!m_sentWindowEvent)
+          ::SetBrowserPluginFullscreen(this, false);
+        setNPWindowRect(frameRect());
+
+        IntRect r(0, 0, width, height);
+        ScrollView* rootView = root();
+        if (rootView)
+            rootView->invalidateRect(r);
+    }
+
+    return NPERR_NO_ERROR;
+}
+
+void PluginView::halt()
+{
+}
+
+void PluginView::restart()
+{
+}
+
+void PluginView::showFullscreen(bool isFullscreen, bool fakeFullscreen, bool fullscreenByPlugin)
+{
+
+  TRACE_INFO(stderr, "%s %d - isFullscreen = %d, fakeFullScreen = %d, fullscreenByPlugin = %d\n",
+         __FUNCTION__, __LINE__, isFullscreen, fakeFullscreen, fullscreenByPlugin);
+
+  bool sendFullscreenEvent = false;
+
+  if (m_isFullscreen && m_isFakeFullscreen != fakeFullscreen)
+  {
+    // if fullscreen is not fake, we can't change the state as if it's fake
+    fakeFullscreen = m_isFakeFullscreen;
+    TRACE_INFO(stderr, "%s %d - setting isFakeFullscreen to current value %d\n",
+           __FUNCTION__, __LINE__, m_isFakeFullscreen);
+  }
+
+  if (m_isFullscreen && !isFullscreen && m_fullscreenByPlugin)
+  {
+//    // if we fullscreen mode was initiated by the plugin, leaving it should be done the same
+//    if (!fullscreenByPlugin)
+//      sendFullscreenEvent = true;
+//    fullscreenByPlugin = true;
+    TRACE_INFO(stderr, "%s %d - setting fullscreenByPlugin to current true\n",
+           __FUNCTION__, __LINE__);
+  }
+
+  m_isFakeFullscreen = fakeFullscreen;
+  m_isFullscreen = isFullscreen;
+  m_shouldClearFullscreen = !fakeFullscreen;
+  m_fullscreenByPlugin = fullscreenByPlugin;
+  ::SetBrowserPluginFullscreen(this, isFullscreen);
+  //setNPWindowRect(frameRect()); // For fullscreen, it is going to override whatever rect we pass in.
+  if (sendFullscreenEvent)
+  {
+    sendFullscreenEventToPlugin(); // For fullscreen, it is going to override whatever rect we pass in.
+  }
+}
+ 
+void PluginView::handleEvent(QEvent* event)
+{
+  switch (event->type())
+  {
+    case QEvent::MouseButtonDblClick:
+    case QEvent::MouseButtonPress:
+    case QEvent::MouseButtonRelease:
+    case QEvent::MouseMove:
+    {
+      QMouseEvent *mevent =  static_cast<QMouseEvent*>(event);
+      PluginEvent evt;
+      memset(&evt, 0, sizeof(PluginEvent));
+      evt.type = PluginMouseEventType;
+ 
+      int state;
+      if (mevent->type() == QMouseEvent::MouseButtonPress)
+        state = PluginMouseButtonDown;
+      else if (mevent->type() == QMouseEvent::MouseButtonRelease)
+        state = PluginMouseButtonUp;
+      else
+        state = PluginMouseButtonMove;
+
+      evt.mouse.state  = state;
+      evt.mouse.xrel  = 0;
+      evt.mouse.yrel  = 0;
+      evt.mouse.which  = 0; // Device index
+      evt.mouse.button = 0; // need to translate from QT::MouseButton to PluginMouseButton
+      evt.mouse.x   = mevent->x();
+      evt.mouse.y   = mevent->y();
+
+      NPEvent pEvt  = &evt;
+
+      //    LOG(Plugins, "Sending Mouse Event state = %d, x,y = %d, %d\n", evt.mouse.state, evt.mouse.x, evt.mouse.y);
+      PluginView::setCurrentPluginView(this);
+      JSC::JSLock::DropAllLocks dropAllLocks(JSC::SilenceAssertionsOnly);
+      setCallingPlugin(true);
+      bool ret = m_plugin->pluginFuncs()->event(m_instance, pEvt);
+      setCallingPlugin(false);
+      PluginView::setCurrentPluginView(0);
+    }
+    break;
+
+  case QEvent::KeyPress:
+  case QEvent::KeyRelease:
+    {
+
+      QKeyEvent *kevent =  static_cast<QKeyEvent*>(event);
+
+
+      PluginEvent evt;
+      memset(&evt, 0, sizeof(PluginEvent));
+      evt.type = PluginKeyEventType;
+
+      switch (kevent->type()) {
+      case QEvent::KeyPress:
+        evt.key.state = PluginKeyDown;
+        break;
+      case QEvent::KeyRelease:
+        evt.key.state = PluginKeyUp;
+        break;
+      default:
+        return;
+      }
+      TRACE_INFO(stderr, "kevent->key() %d kevent->text().unicode()[0].unicode() %d\n", kevent->key(), kevent->text().unicode()[0].unicode());
+
+      evt.key.mod   = kevent->modifiers();// event->keyEvent()->modifiers();
+
+      if (!kevent->key() || kevent->key() == kevent->text().unicode()[0].unicode())
+      {
+        evt.key.unicode = kevent->text().unicode()[0].unicode();
+      }
+      else
+      {
+        evt.key.sym = evt.key.scancode = kevent->text().unicode()[0].unicode();
+      }
+
+      TRACE_INFO(stderr, "handle event - keyboard event %d %d %d %d\n", (int)evt.key.state, (int)evt.key.scancode, (int)evt.key.sym, (int)evt.key.mod);
+
+      NPEvent pEvt  = &evt;
+
+      LOG(Plugins, "Sending Keyboard Event\n");
+      PluginView::setCurrentPluginView(this);
+      JSC::JSLock::DropAllLocks dropAllLocks(JSC::SilenceAssertionsOnly);
+      setCallingPlugin(true);
+      bool ret = m_plugin->pluginFuncs()->event(m_instance, pEvt);
+      setCallingPlugin(false);
+      PluginView::setCurrentPluginView(0);
+    }
+    break;
+
+  default:
+      break;
+  }
+}
+
+} // namespace WebCore
diff --git a/WebCore/plugins/npapi.cpp b/WebCore/plugins/npapi.cpp
index 4135b64..65d9bb1 100644
--- a/WebCore/plugins/npapi.cpp
+++ b/WebCore/plugins/npapi.cpp
@@ -104,6 +104,10 @@ NPError NPN_DestroyStream(NPP instance, NPStream* stream, NPReason reason)
     return pluginViewForInstance(instance)->destroyStream(stream, reason);
 }
 
+#if defined(XP_EMBEDDED)
+extern "C" __attribute__((visibility("default"))) const char* NPN_UserAgent(NPP instance);
+#endif
+
 const char* NPN_UserAgent(NPP instance)
 {
     PluginView* view = pluginViewForInstance(instance);
@@ -175,3 +179,13 @@ void NPN_PluginThreadAsyncCall(NPP instance, void (*func) (void *), void *userDa
 {
     PluginMainThreadScheduler::scheduler().scheduleCall(instance, func, userData);
 }
+
+uint32 NPN_ScheduleTimer(NPP instance, uint32 interval, NPBool repeat, void (*timerFunc)(NPP instance, uint32 timerID))
+{
+    return pluginViewForInstance(instance)->scheduleTimer(interval, repeat, timerFunc);
+}
+
+void NPN_UnscheduleTimer(NPP instance, uint32 timerID)
+{
+    pluginViewForInstance(instance)->unscheduleTimer(timerID);
+}
diff --git a/WebCore/plugins/npfunctions.h b/WebCore/plugins/npfunctions.h
index e28bf5e..9cee289 100644
--- a/WebCore/plugins/npfunctions.h
+++ b/WebCore/plugins/npfunctions.h
@@ -199,7 +199,7 @@ typedef void (*BP_CreatePluginMIMETypesPreferencesFuncPtr)(void);
 typedef NPError (*MainFuncPtr)(NPNetscapeFuncs*, NPPluginFuncs*, NPP_ShutdownProcPtr*);
 #endif
 
-#if defined(XP_UNIX)
+#if defined(XP_UNIX) || defined(XP_EMBEDDED)
 typedef EXPORTED_CALLBACK(NPError, NP_InitializeFuncPtr)(NPNetscapeFuncs*, NPPluginFuncs*);
 typedef EXPORTED_CALLBACK(char*, NP_GetMIMEDescriptionFuncPtr)(void);
 #else
diff --git a/WebCore/plugins/qt/PluginPackageQt.cpp b/WebCore/plugins/qt/PluginPackageQt.cpp
index d5292fe..60d9b18 100644
--- a/WebCore/plugins/qt/PluginPackageQt.cpp
+++ b/WebCore/plugins/qt/PluginPackageQt.cpp
@@ -37,6 +37,12 @@ namespace WebCore {
 
 typedef void gtkInitFunc(int *argc, char ***argv);
 
+#ifdef XP_EMBEDDED
+void PluginPackage::determineQuirks(const String& mimeType)
+{
+}
+#endif
+
 bool PluginPackage::fetchInfo()
 {
     if (!load())
@@ -102,7 +108,7 @@ bool PluginPackage::load()
     m_module = new QLibrary((QString)m_path);
     m_module->setLoadHints(QLibrary::ResolveAllSymbolsHint);
     if (!m_module->load()) {
-        LOG(Plugins, "%s not loaded (%s)", m_path.utf8().data(),
+        LOG(Plugins, "%s not loaded (%s)\n", m_path.utf8().data(),
                 m_module->errorString().toLatin1().constData());
         return false;
     }
@@ -150,7 +156,7 @@ bool PluginPackage::load()
 #endif
     }
 
-#if defined(XP_UNIX)
+#if defined(XP_UNIX) || defined(XP_EMBEDDED)
     npErr = NP_Initialize(&m_browserFuncs, &m_pluginFuncs);
 #else
     npErr = NP_Initialize(&m_browserFuncs);
@@ -162,6 +168,7 @@ bool PluginPackage::load()
     return true;
 
 abort:
+    LOG(Plugins, "PluginPackage FAILD TO LOAD!");
     unloadWithoutShutdown();
     return false;
 }
diff --git a/WebKit.pri b/WebKit.pri
index bb3fd71..96ee032 100644
--- a/WebKit.pri
+++ b/WebKit.pri
@@ -52,9 +52,24 @@ BASE_DIR = $$PWD
 symbian {
     INCLUDEPATH += $$PWD/include/QtWebKit
 } else {
-    INCLUDEPATH += $$OUTPUT_DIR/include/QtWebKit
+    INCLUDEPATH += $$OUTPUT_DIR/include/QtWebKit 
 }
 
+embedded {
+     INCLUDEPATH += /opt/canmore/local/include
+     LIBS += -L/opt/canmore/local/lib
+     QMAKE_LFLAGS_NOUNDEF      =
+     QMAKE_LFLAGS_DEBUG = -L/opt/canmore/local/lib
+     QMAKE_LFLAGS_RELEASE = -L/opt/canmore/local/lib
+}
+
+
+    INCLUDEPATH += /opt/canmore/local/include
+    LIBS += -L/opt/canmore/local/lib
+    QMAKE_LFLAGS_NOUNDEF      =
+    QMAKE_LFLAGS_DEBUG = -L/opt/canmore/local/lib
+    QMAKE_LFLAGS_RELEASE = -L/opt/canmore/local/lib
+
 CONFIG -= warn_on
 *-g++*:QMAKE_CXXFLAGS += -Wall -Wreturn-type -fno-strict-aliasing -Wcast-align -Wchar-subscripts -Wformat-security -Wreturn-type -Wno-unused-parameter -Wno-sign-compare -Wno-switch -Wno-switch-enum -Wundef -Wmissing-noreturn -Winit-self
 
diff --git a/WebKit.pro b/WebKit.pro
index c7df391..5ecefee 100644
--- a/WebKit.pro
+++ b/WebKit.pro
@@ -2,21 +2,25 @@ TEMPLATE = subdirs
 CONFIG += ordered
 
 include(WebKit.pri)
-
+ 
 SUBDIRS += \
         JavaScriptCore \
         WebCore
 
 # If the source exists, built it
-exists($$PWD/WebKitTools/QtTestBrowser): SUBDIRS += WebKitTools/QtTestBrowser
+!embedded {
+ exists($$PWD/WebKitTools/QtTestBrowser): SUBDIRS += WebKitTools/QtTestBrowser
+}
 contains(QT_CONFIG, declarative) {
     exists($$PWD/WebKit/qt/declarative): SUBDIRS += WebKit/qt/declarative
 }
 exists($$PWD/JavaScriptCore/jsc.pro): SUBDIRS += JavaScriptCore/jsc.pro
+!embedded {
 exists($$PWD/WebKit/qt/tests): SUBDIRS += WebKit/qt/tests
 exists($$PWD/WebKitTools/DumpRenderTree/qt/DumpRenderTree.pro): SUBDIRS += WebKitTools/DumpRenderTree/qt/DumpRenderTree.pro
+}
 
-!win32:!symbian {
+!win32:!symbian:!embedded {
     exists($$PWD/WebKitTools/DumpRenderTree/qt/ImageDiff.pro): SUBDIRS += WebKitTools/DumpRenderTree/qt/ImageDiff.pro
     exists($$PWD/WebKitTools/DumpRenderTree/qt/TestNetscapePlugin/TestNetscapePlugin.pro): SUBDIRS += WebKitTools/DumpRenderTree/qt/TestNetscapePlugin/TestNetscapePlugin.pro
 }
diff --git a/WebKit/qt/Api/qwebelement.cpp b/WebKit/qt/Api/qwebelement.cpp
index 69146a2..6fd6f9a 100644
--- a/WebKit/qt/Api/qwebelement.cpp
+++ b/WebKit/qt/Api/qwebelement.cpp
@@ -36,6 +36,7 @@
 #include "JSHTMLElement.h"
 #include "JSObject.h"
 #include "NodeList.h"
+#include "PluginView.h"
 #include "PropertyNameArray.h"
 #include "RenderImage.h"
 #include "StaticNodeList.h"
@@ -1461,6 +1462,22 @@ void QWebElement::render(QPainter* painter)
     context.restore();
 }
 
+void QWebElement::showFullscreen(bool isFullscreen, bool isFakeFullScreen, void* pluginIdentifier)
+{
+    if (!pluginIdentifier)
+        return;
+    PluginView* pluginView = reinterpret_cast<PluginView*>(pluginIdentifier);
+    pluginView->showFullscreen(isFullscreen, isFakeFullScreen, false);
+}
+
+void QWebElement::handleEvent(QEvent* event, void* pluginIdentifier)
+{
+    if (!pluginIdentifier)
+        return;
+    PluginView* pluginView = reinterpret_cast<PluginView*>(pluginIdentifier);
+    pluginView->handleEvent(event);
+}
+
 class QWebElementCollectionPrivate : public QSharedData
 {
 public:
diff --git a/WebKit/qt/Api/qwebelement.h b/WebKit/qt/Api/qwebelement.h
index a87d388..dd75d75 100644
--- a/WebKit/qt/Api/qwebelement.h
+++ b/WebKit/qt/Api/qwebelement.h
@@ -147,6 +147,8 @@ public:
     void setStyleProperty(const QString& name, const QString& value);
 
     void render(QPainter* painter);
+    void showFullscreen(bool isFullscreen, bool isFakeFullScreen, void* pluginIdentifier);
+    void handleEvent(QEvent* event, void* pluginIdentifier);
 
 private:
     explicit QWebElement(WebCore::Element*);
@@ -155,6 +157,7 @@ private:
     static QWebElement enclosingElement(WebCore::Node*);
 
     friend class QWebFrame;
+    friend class QWebFramePrivate;
     friend class QWebElementCollection;
     friend class QWebHitTestResult;
     friend class QWebHitTestResultPrivate;
diff --git a/WebKit/qt/Api/qwebframe.cpp b/WebKit/qt/Api/qwebframe.cpp
index 4fe784f..49e249a 100644
--- a/WebKit/qt/Api/qwebframe.cpp
+++ b/WebKit/qt/Api/qwebframe.cpp
@@ -523,6 +523,12 @@ void QWebFramePrivate::renderRelativeCoords(GraphicsContext* context, QWebFrame:
     }
 }
 
+void QWebFramePrivate::pluginCreated(Element* element, void* pluginInstance)
+{
+    QWebElement pluginElement(element);
+    emit q->pluginCreated(pluginElement, pluginInstance);
+}
+
 /*!
     \class QWebFrame
     \since 4.4
diff --git a/WebKit/qt/Api/qwebframe.h b/WebKit/qt/Api/qwebframe.h
index ce9805b..220d134 100644
--- a/WebKit/qt/Api/qwebframe.h
+++ b/WebKit/qt/Api/qwebframe.h
@@ -220,6 +220,8 @@ Q_SIGNALS:
 
     void pageChanged();
 
+    void pluginCreated(const QWebElement& pluginElement, void* pluginIdentifier);
+
 private:
     friend class QGraphicsWebView;
     friend class QWebPage;
diff --git a/WebKit/qt/Api/qwebframe_p.h b/WebKit/qt/Api/qwebframe_p.h
index fcc37e7..c4ff8d0 100644
--- a/WebKit/qt/Api/qwebframe_p.h
+++ b/WebKit/qt/Api/qwebframe_p.h
@@ -88,6 +88,8 @@ public:
     void renderFromTiledBackingStore(WebCore::GraphicsContext*, const QRegion& clip);
 #endif
 
+    void pluginCreated(WebCore::Element* element, void* pluginIdentifier);
+
     QWebFrame *q;
     Qt::ScrollBarPolicy horizontalScrollBarPolicy;
     Qt::ScrollBarPolicy verticalScrollBarPolicy;
diff --git a/WebKit/qt/Api/qwebsettings.cpp b/WebKit/qt/Api/qwebsettings.cpp
index d907d86..3ff315e 100644
--- a/WebKit/qt/Api/qwebsettings.cpp
+++ b/WebKit/qt/Api/qwebsettings.cpp
@@ -28,6 +28,8 @@
 #include "CrossOriginPreflightResultCache.h"
 #include "Database.h"
 #include "FontCache.h"
+#include "JSDOMWindowBase.h"
+#include "JSGlobalData.h"
 #include "Page.h"
 #include "PageCache.h"
 #include "Settings.h"
@@ -997,6 +999,17 @@ qint64 QWebSettings::offlineWebApplicationCacheQuota()
 }
 
 /*!
+    \since Boxee
+
+    Set the timeout for JavaScript interrupts, or 0 to disable timeout.
+*/
+void QWebSettings::setJavaScriptInterruptTimeoutInterval(quint32 timeoutInterval)
+{
+    WebCore::JSDOMWindowBase::commonJSGlobalData()->timeoutChecker.setTimeoutInterval(timeoutInterval);
+}
+
+
+/*!
     \since 4.6
 
     Sets the path for HTML5 local storage to \a path.
diff --git a/WebKit/qt/Api/qwebsettings.h b/WebKit/qt/Api/qwebsettings.h
index 156f633..09804e1 100644
--- a/WebKit/qt/Api/qwebsettings.h
+++ b/WebKit/qt/Api/qwebsettings.h
@@ -141,6 +141,8 @@ public:
 
     static void enablePersistentStorage(const QString& path = QString());
 
+    static void setJavaScriptInterruptTimeoutInterval(quint32 timeoutInterval);
+
     inline QWebSettingsPrivate* handle() const { return d; }
 
 private:
diff --git a/WebKit/qt/WebCoreSupport/FrameLoaderClientQt.cpp b/WebKit/qt/WebCoreSupport/FrameLoaderClientQt.cpp
index dcbf614..d3e63f9 100644
--- a/WebKit/qt/WebCoreSupport/FrameLoaderClientQt.cpp
+++ b/WebKit/qt/WebCoreSupport/FrameLoaderClientQt.cpp
@@ -1367,14 +1367,42 @@ PassRefPtr<Widget> FrameLoaderClientQt::createPlugin(const IntSize& pluginSize,
                 if (wmodeIndex == -1) {
                     params.append("wmode");
                     values.append("opaque");
-                } else
+                } else {
+#ifdef Q_WS_X11
+                    // wmode=opaque only required on X11, http://blog.forwardbias.in/2009/12
                     values[wmodeIndex] = "opaque";
+#endif
+                }
+
+                size_t fsIndex = params.find("allowfullscreen");
+                if (fsIndex == -1) {
+                    params.append("allowfullscreen");
+                    values.append("true");
+                } else {
+                    values[fsIndex] = "true";
+                }
+
+                size_t saIndex = params.find("allowscriptaccess");
+                if (saIndex == -1) {
+                    params.append("allowscriptaccess");
+                    values.append("always");
+                } else {
+                    values[saIndex] = "always";
+                }
+
+//                size_t scIndex = params.find("scalemode");
+//                if (scIndex != -1) {
+//                    values[scIndex] = "showAll";
+//                }
             }
 #endif
         }
 
         RefPtr<PluginView> pluginView = PluginView::create(m_frame, pluginSize, element, url,
             params, values, mimeType, loadManually);
+        
+        // Boxee API to notify of new plugin
+        m_webFrame->d->pluginCreated(element, pluginView.get());
         return pluginView;
     }
 
